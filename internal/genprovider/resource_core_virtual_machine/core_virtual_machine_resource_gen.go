// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_core_virtual_machine

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CoreVirtualMachineResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"assign_floating_ip": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "When this field is set to `true`, it attaches a [public IP address](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/public-ip)to the virtual machine, enabling internet accessibility.",
				MarkdownDescription: "When this field is set to `true`, it attaches a [public IP address](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/public-ip)to the virtual machine, enabling internet accessibility.",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
				Default: booldefault.StaticBool(false),
			},
			"callback_url": schema.StringAttribute{
				Optional:            true,
				Description:         "An optional URL where actions performed on the virtual machine will be sent. For additional information on event callbacks, [**click here**](https://infrahub-doc.nexgencloud.com/docs/features/webhooks-callbacks).",
				MarkdownDescription: "An optional URL where actions performed on the virtual machine will be sent. For additional information on event callbacks, [**click here**](https://infrahub-doc.nexgencloud.com/docs/features/webhooks-callbacks).",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					stringvalidator.LengthAtMost(250),
				},
			},
			"create_bootable_volume": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Indicates whether to create a bootable volume for the virtual machine. When set to `true`, a bootable volume will be created; the default value is `false`.",
				MarkdownDescription: "Indicates whether to create a bootable volume for the virtual machine. When set to `true`, a bootable volume will be created; the default value is `false`.",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
				Default: booldefault.StaticBool(false),
			},
			"created_at": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"environment": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"features": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"network_optimised": schema.BoolAttribute{
								Computed: true,
							},
						},
						CustomType: FeaturesType{
							ObjectType: types.ObjectType{
								AttrTypes: FeaturesValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"org_id": schema.Int64Attribute{
						Computed: true,
					},
					"region": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: EnvironmentType{
					ObjectType: types.ObjectType{
						AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"environment_name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the [environment](https://infrahub-doc.nexgencloud.com/docs/features/environments-available-features) in which the virtual machine is to be created.",
				MarkdownDescription: "The name of the [environment](https://infrahub-doc.nexgencloud.com/docs/features/environments-available-features) in which the virtual machine is to be created.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"fixed_ip": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"flavor": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cpu": schema.Int64Attribute{
						Computed: true,
					},
					"disk": schema.Int64Attribute{
						Computed: true,
					},
					"ephemeral": schema.Int64Attribute{
						Computed: true,
					},
					"gpu": schema.StringAttribute{
						Computed: true,
					},
					"gpu_count": schema.Int64Attribute{
						Computed: true,
					},
					"id": schema.Int64Attribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"ram": schema.NumberAttribute{
						Computed: true,
					},
				},
				CustomType: FlavorType{
					ObjectType: types.ObjectType{
						AttrTypes: FlavorValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"flavor_name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the GPU hardware configuration ([flavor](https://infrahub-doc.nexgencloud.com/docs/hardware/flavors)) for the virtual machines being created.",
				MarkdownDescription: "The name of the GPU hardware configuration ([flavor](https://infrahub-doc.nexgencloud.com/docs/hardware/flavors)) for the virtual machines being created.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"floating_ip": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"floating_ip_status": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"id": schema.Int64Attribute{
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"image": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: ImageType{
					ObjectType: types.ObjectType{
						AttrTypes: ImageValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"image_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The [operating system (OS) image](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/images) name designated for installation on the virtual machine.",
				MarkdownDescription: "The [operating system (OS) image](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/images) name designated for installation on the virtual machine.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"key_name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the existing SSH key pair to be used for secure access to the virtual machine. For additional information on SSH key pairs, [**click here**](https://infrahub-doc.nexgencloud.com/docs/getting-started/create-keypair).",
				MarkdownDescription: "The name of the existing SSH key pair to be used for secure access to the virtual machine. For additional information on SSH key pairs, [**click here**](https://infrahub-doc.nexgencloud.com/docs/getting-started/create-keypair).",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"keypair": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: KeypairType{
					ObjectType: types.ObjectType{
						AttrTypes: KeypairValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"labels": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
				Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
			},
			"locked": schema.BoolAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the virtual machine being created.",
				MarkdownDescription: "The name of the virtual machine being created.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.LengthAtMost(50),
				},
			},
			"os": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"power_state": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"security_rules": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_at": schema.StringAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
						},
						"direction": schema.StringAttribute{
							Computed:            true,
							Description:         "The direction of traffic that the firewall rule applies to.",
							MarkdownDescription: "The direction of traffic that the firewall rule applies to.",
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
						},
						"ethertype": schema.StringAttribute{
							Computed:            true,
							Description:         "The Ethernet type associated with the rule.",
							MarkdownDescription: "The Ethernet type associated with the rule.",
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
						},
						"id": schema.Int64Attribute{
							Computed: true,
							PlanModifiers: []planmodifier.Int64{
								int64planmodifier.UseStateForUnknown(),
							},
						},
						"port_range_max": schema.Int64Attribute{
							Computed: true,
							PlanModifiers: []planmodifier.Int64{
								int64planmodifier.UseStateForUnknown(),
							},
						},
						"port_range_min": schema.Int64Attribute{
							Computed: true,
							PlanModifiers: []planmodifier.Int64{
								int64planmodifier.UseStateForUnknown(),
							},
						},
						"protocol": schema.StringAttribute{
							Computed:            true,
							Description:         "The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.",
							MarkdownDescription: "The network protocol associated with the rule. Call the [`GET /core/sg-rules-protocols`](https://infrahub-api-doc.nexgencloud.com/#get-/core/sg-rules-protocols) endpoint to retrieve a list of permitted network protocols.",
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf(
									"any",
									"ah",
									"dccp",
									"egp",
									"esp",
									"gre",
									"hopopt",
									"icmp",
									"igmp",
									"ip",
									"ipip",
									"ipv6-encap",
									"ipv6-frag",
									"ipv6-icmp",
									"icmpv6",
									"ipv6-nonxt",
									"ipv6-opts",
									"ipv6-route",
									"ospf",
									"pgm",
									"rsvp",
									"sctp",
									"tcp",
									"udp",
									"udplite",
									"vrrp",
								),
							},
						},
						"remote_ip_prefix": schema.StringAttribute{
							Computed:            true,
							Description:         "The IP address range that is allowed to access the specified port. Use \"0.0.0.0/0\" to allow any IP address.",
							MarkdownDescription: "The IP address range that is allowed to access the specified port. Use \"0.0.0.0/0\" to allow any IP address.",
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
						},
						"status": schema.StringAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
						},
						"virtual_machine_id": schema.Int64Attribute{
							Computed: true,
							PlanModifiers: []planmodifier.Int64{
								int64planmodifier.UseStateForUnknown(),
							},
						},
					},
					CustomType: SecurityRulesType{
						ObjectType: types.ObjectType{
							AttrTypes: SecurityRulesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.UseStateForUnknown(),
				},
			},
			"status": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"user_data": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Optional initialization configuration commands to manage the configuration of a virtual machine at launch using cloud-init scripts. For more information about custom VM configuration using cloud-init, [**click here**](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/initialization-configuration).",
				MarkdownDescription: "Optional initialization configuration commands to manage the configuration of a virtual machine at launch using cloud-init scripts. For more information about custom VM configuration using cloud-init, [**click here**](https://infrahub-doc.nexgencloud.com/docs/virtual-machines/initialization-configuration).",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"vm_state": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"volume_attachments": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_at": schema.StringAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"device": schema.StringAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"status": schema.StringAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"volume": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
								"id": schema.Int64Attribute{
									Computed: true,
									PlanModifiers: []planmodifier.Int64{
										int64planmodifier.RequiresReplace(),
									},
								},
								"name": schema.StringAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
								"size": schema.Int64Attribute{
									Computed: true,
									PlanModifiers: []planmodifier.Int64{
										int64planmodifier.RequiresReplace(),
									},
								},
								"volume_type": schema.StringAttribute{
									Computed: true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
								},
							},
							CustomType: VolumeType{
								ObjectType: types.ObjectType{
									AttrTypes: VolumeValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
							PlanModifiers: []planmodifier.Object{
								objectplanmodifier.RequiresReplace(),
							},
						},
					},
					CustomType: VolumeAttachmentsType{
						ObjectType: types.ObjectType{
							AttrTypes: VolumeAttachmentsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},
			},
			"volume_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The names of the volume(s) to be attached to the virtual machine being created.",
				MarkdownDescription: "The names of the volume(s) to be attached to the virtual machine being created.",
			},
		},
		Blocks: map[string]schema.Block{
			"profile": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
						"name": schema.StringAttribute{
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplace(),
							},
						},
					},
					CustomType: ProfileType{
						ObjectType: types.ObjectType{
							AttrTypes: ProfileValue{}.AttributeTypes(ctx),
						},
					},
				},
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

type CoreVirtualMachineModel struct {
	AssignFloatingIp     types.Bool       `tfsdk:"assign_floating_ip"`
	CallbackUrl          types.String     `tfsdk:"callback_url"`
	CreateBootableVolume types.Bool       `tfsdk:"create_bootable_volume"`
	CreatedAt            types.String     `tfsdk:"created_at"`
	Environment          EnvironmentValue `tfsdk:"environment"`
	EnvironmentName      types.String     `tfsdk:"environment_name"`
	FixedIp              types.String     `tfsdk:"fixed_ip"`
	Flavor               FlavorValue      `tfsdk:"flavor"`
	FlavorName           types.String     `tfsdk:"flavor_name"`
	FloatingIp           types.String     `tfsdk:"floating_ip"`
	FloatingIpStatus     types.String     `tfsdk:"floating_ip_status"`
	Id                   types.Int64      `tfsdk:"id"`
	Image                ImageValue       `tfsdk:"image"`
	ImageName            types.String     `tfsdk:"image_name"`
	KeyName              types.String     `tfsdk:"key_name"`
	Keypair              KeypairValue     `tfsdk:"keypair"`
	Labels               types.List       `tfsdk:"labels"`
	Locked               types.Bool       `tfsdk:"locked"`
	Name                 types.String     `tfsdk:"name"`
	Os                   types.String     `tfsdk:"os"`
	PowerState           types.String     `tfsdk:"power_state"`
	SecurityRules        types.List       `tfsdk:"security_rules"`
	Status               types.String     `tfsdk:"status"`
	UserData             types.String     `tfsdk:"user_data"`
	VmState              types.String     `tfsdk:"vm_state"`
	VolumeAttachments    types.List       `tfsdk:"volume_attachments"`
	VolumeName           types.String     `tfsdk:"volume_name"`
	Profile              types.List       `tfsdk:"profile"`
}

var _ basetypes.ObjectTypable = EnvironmentType{}

type EnvironmentType struct {
	basetypes.ObjectType
}

func (t EnvironmentType) Equal(o attr.Type) bool {
	other, ok := o.(EnvironmentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EnvironmentType) String() string {
	return "EnvironmentType"
}

func (t EnvironmentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return nil, diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ObjectValue, was: %T`, featuresAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.Int64Value, was: %T`, orgIdAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EnvironmentValue{
		Features: featuresVal,
		Id:       idVal,
		Name:     nameVal,
		OrgId:    orgIdVal,
		Region:   regionVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewEnvironmentValueNull() EnvironmentValue {
	return EnvironmentValue{
		state: attr.ValueStateNull,
	}
}

func NewEnvironmentValueUnknown() EnvironmentValue {
	return EnvironmentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEnvironmentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EnvironmentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EnvironmentValue Attribute Value",
				"While creating a EnvironmentValue value, a missing attribute value was detected. "+
					"A EnvironmentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvironmentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EnvironmentValue Attribute Type",
				"While creating a EnvironmentValue value, an invalid attribute value was detected. "+
					"A EnvironmentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvironmentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EnvironmentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EnvironmentValue Attribute Value",
				"While creating a EnvironmentValue value, an extra attribute value was detected. "+
					"A EnvironmentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EnvironmentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEnvironmentValueUnknown(), diags
	}

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ObjectValue, was: %T`, featuresAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.Int64Value, was: %T`, orgIdAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return NewEnvironmentValueUnknown(), diags
	}

	return EnvironmentValue{
		Features: featuresVal,
		Id:       idVal,
		Name:     nameVal,
		OrgId:    orgIdVal,
		Region:   regionVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewEnvironmentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EnvironmentValue {
	object, diags := NewEnvironmentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEnvironmentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EnvironmentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEnvironmentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEnvironmentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEnvironmentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEnvironmentValueMust(EnvironmentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EnvironmentType) ValueType(ctx context.Context) attr.Value {
	return EnvironmentValue{}
}

var _ basetypes.ObjectValuable = EnvironmentValue{}

type EnvironmentValue struct {
	Features basetypes.ObjectValue `tfsdk:"features"`
	Id       basetypes.Int64Value  `tfsdk:"id"`
	Name     basetypes.StringValue `tfsdk:"name"`
	OrgId    basetypes.Int64Value  `tfsdk:"org_id"`
	Region   basetypes.StringValue `tfsdk:"region"`
	state    attr.ValueState
}

func (v EnvironmentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["features"] = basetypes.ObjectType{
		AttrTypes: FeaturesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Features.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["features"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EnvironmentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EnvironmentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EnvironmentValue) String() string {
	return "EnvironmentValue"
}

func (v EnvironmentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var features basetypes.ObjectValue

	if v.Features.IsNull() {
		features = types.ObjectNull(
			FeaturesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Features.IsUnknown() {
		features = types.ObjectUnknown(
			FeaturesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Features.IsNull() && !v.Features.IsUnknown() {
		features = types.ObjectValueMust(
			FeaturesValue{}.AttributeTypes(ctx),
			v.Features.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"features": basetypes.ObjectType{
			AttrTypes: FeaturesValue{}.AttributeTypes(ctx),
		},
		"id":     basetypes.Int64Type{},
		"name":   basetypes.StringType{},
		"org_id": basetypes.Int64Type{},
		"region": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"features": features,
			"id":       v.Id,
			"name":     v.Name,
			"org_id":   v.OrgId,
			"region":   v.Region,
		})

	return objVal, diags
}

func (v EnvironmentValue) Equal(o attr.Value) bool {
	other, ok := o.(EnvironmentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Features.Equal(other.Features) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	return true
}

func (v EnvironmentValue) Type(ctx context.Context) attr.Type {
	return EnvironmentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EnvironmentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"features": basetypes.ObjectType{
			AttrTypes: FeaturesValue{}.AttributeTypes(ctx),
		},
		"id":     basetypes.Int64Type{},
		"name":   basetypes.StringType{},
		"org_id": basetypes.Int64Type{},
		"region": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FeaturesType{}

type FeaturesType struct {
	basetypes.ObjectType
}

func (t FeaturesType) Equal(o attr.Type) bool {
	other, ok := o.(FeaturesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FeaturesType) String() string {
	return "FeaturesType"
}

func (t FeaturesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networkOptimisedAttribute, ok := attributes["network_optimised"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_optimised is missing from object`)

		return nil, diags
	}

	networkOptimisedVal, ok := networkOptimisedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_optimised expected to be basetypes.BoolValue, was: %T`, networkOptimisedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FeaturesValue{
		NetworkOptimised: networkOptimisedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFeaturesValueNull() FeaturesValue {
	return FeaturesValue{
		state: attr.ValueStateNull,
	}
}

func NewFeaturesValueUnknown() FeaturesValue {
	return FeaturesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFeaturesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FeaturesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FeaturesValue Attribute Value",
				"While creating a FeaturesValue value, a missing attribute value was detected. "+
					"A FeaturesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FeaturesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FeaturesValue Attribute Type",
				"While creating a FeaturesValue value, an invalid attribute value was detected. "+
					"A FeaturesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FeaturesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FeaturesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FeaturesValue Attribute Value",
				"While creating a FeaturesValue value, an extra attribute value was detected. "+
					"A FeaturesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FeaturesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFeaturesValueUnknown(), diags
	}

	networkOptimisedAttribute, ok := attributes["network_optimised"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_optimised is missing from object`)

		return NewFeaturesValueUnknown(), diags
	}

	networkOptimisedVal, ok := networkOptimisedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_optimised expected to be basetypes.BoolValue, was: %T`, networkOptimisedAttribute))
	}

	if diags.HasError() {
		return NewFeaturesValueUnknown(), diags
	}

	return FeaturesValue{
		NetworkOptimised: networkOptimisedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFeaturesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FeaturesValue {
	object, diags := NewFeaturesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFeaturesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FeaturesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFeaturesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFeaturesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFeaturesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFeaturesValueMust(FeaturesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FeaturesType) ValueType(ctx context.Context) attr.Value {
	return FeaturesValue{}
}

var _ basetypes.ObjectValuable = FeaturesValue{}

type FeaturesValue struct {
	NetworkOptimised basetypes.BoolValue `tfsdk:"network_optimised"`
	state            attr.ValueState
}

func (v FeaturesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["network_optimised"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.NetworkOptimised.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_optimised"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FeaturesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FeaturesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FeaturesValue) String() string {
	return "FeaturesValue"
}

func (v FeaturesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"network_optimised": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"network_optimised": v.NetworkOptimised,
		})

	return objVal, diags
}

func (v FeaturesValue) Equal(o attr.Value) bool {
	other, ok := o.(FeaturesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NetworkOptimised.Equal(other.NetworkOptimised) {
		return false
	}

	return true
}

func (v FeaturesValue) Type(ctx context.Context) attr.Type {
	return FeaturesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FeaturesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"network_optimised": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = FlavorType{}

type FlavorType struct {
	basetypes.ObjectType
}

func (t FlavorType) Equal(o attr.Type) bool {
	other, ok := o.(FlavorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FlavorType) String() string {
	return "FlavorType"
}

func (t FlavorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return nil, diags
	}

	cpuVal, ok := cpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be basetypes.Int64Value, was: %T`, cpuAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return nil, diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	ephemeralAttribute, ok := attributes["ephemeral"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ephemeral is missing from object`)

		return nil, diags
	}

	ephemeralVal, ok := ephemeralAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ephemeral expected to be basetypes.Int64Value, was: %T`, ephemeralAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return nil, diags
	}

	gpuVal, ok := gpuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be basetypes.StringValue, was: %T`, gpuAttribute))
	}

	gpuCountAttribute, ok := attributes["gpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_count is missing from object`)

		return nil, diags
	}

	gpuCountVal, ok := gpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_count expected to be basetypes.Int64Value, was: %T`, gpuCountAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ramAttribute, ok := attributes["ram"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram is missing from object`)

		return nil, diags
	}

	ramVal, ok := ramAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram expected to be basetypes.NumberValue, was: %T`, ramAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FlavorValue{
		Cpu:       cpuVal,
		Disk:      diskVal,
		Ephemeral: ephemeralVal,
		Gpu:       gpuVal,
		GpuCount:  gpuCountVal,
		Id:        idVal,
		Name:      nameVal,
		Ram:       ramVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFlavorValueNull() FlavorValue {
	return FlavorValue{
		state: attr.ValueStateNull,
	}
}

func NewFlavorValueUnknown() FlavorValue {
	return FlavorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFlavorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FlavorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FlavorValue Attribute Value",
				"While creating a FlavorValue value, a missing attribute value was detected. "+
					"A FlavorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FlavorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FlavorValue Attribute Type",
				"While creating a FlavorValue value, an invalid attribute value was detected. "+
					"A FlavorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FlavorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FlavorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FlavorValue Attribute Value",
				"While creating a FlavorValue value, an extra attribute value was detected. "+
					"A FlavorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FlavorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFlavorValueUnknown(), diags
	}

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	cpuVal, ok := cpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be basetypes.Int64Value, was: %T`, cpuAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	ephemeralAttribute, ok := attributes["ephemeral"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ephemeral is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	ephemeralVal, ok := ephemeralAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ephemeral expected to be basetypes.Int64Value, was: %T`, ephemeralAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	gpuVal, ok := gpuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be basetypes.StringValue, was: %T`, gpuAttribute))
	}

	gpuCountAttribute, ok := attributes["gpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_count is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	gpuCountVal, ok := gpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_count expected to be basetypes.Int64Value, was: %T`, gpuCountAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ramAttribute, ok := attributes["ram"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	ramVal, ok := ramAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram expected to be basetypes.NumberValue, was: %T`, ramAttribute))
	}

	if diags.HasError() {
		return NewFlavorValueUnknown(), diags
	}

	return FlavorValue{
		Cpu:       cpuVal,
		Disk:      diskVal,
		Ephemeral: ephemeralVal,
		Gpu:       gpuVal,
		GpuCount:  gpuCountVal,
		Id:        idVal,
		Name:      nameVal,
		Ram:       ramVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFlavorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FlavorValue {
	object, diags := NewFlavorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFlavorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FlavorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFlavorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFlavorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFlavorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFlavorValueMust(FlavorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FlavorType) ValueType(ctx context.Context) attr.Value {
	return FlavorValue{}
}

var _ basetypes.ObjectValuable = FlavorValue{}

type FlavorValue struct {
	Cpu       basetypes.Int64Value  `tfsdk:"cpu"`
	Disk      basetypes.Int64Value  `tfsdk:"disk"`
	Ephemeral basetypes.Int64Value  `tfsdk:"ephemeral"`
	Gpu       basetypes.StringValue `tfsdk:"gpu"`
	GpuCount  basetypes.Int64Value  `tfsdk:"gpu_count"`
	Id        basetypes.Int64Value  `tfsdk:"id"`
	Name      basetypes.StringValue `tfsdk:"name"`
	Ram       basetypes.NumberValue `tfsdk:"ram"`
	state     attr.ValueState
}

func (v FlavorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disk"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ephemeral"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ram"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Cpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu"] = val

		val, err = v.Disk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk"] = val

		val, err = v.Ephemeral.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ephemeral"] = val

		val, err = v.Gpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu"] = val

		val, err = v.GpuCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_count"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Ram.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FlavorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FlavorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FlavorValue) String() string {
	return "FlavorValue"
}

func (v FlavorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu":       basetypes.Int64Type{},
		"disk":      basetypes.Int64Type{},
		"ephemeral": basetypes.Int64Type{},
		"gpu":       basetypes.StringType{},
		"gpu_count": basetypes.Int64Type{},
		"id":        basetypes.Int64Type{},
		"name":      basetypes.StringType{},
		"ram":       basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu":       v.Cpu,
			"disk":      v.Disk,
			"ephemeral": v.Ephemeral,
			"gpu":       v.Gpu,
			"gpu_count": v.GpuCount,
			"id":        v.Id,
			"name":      v.Name,
			"ram":       v.Ram,
		})

	return objVal, diags
}

func (v FlavorValue) Equal(o attr.Value) bool {
	other, ok := o.(FlavorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cpu.Equal(other.Cpu) {
		return false
	}

	if !v.Disk.Equal(other.Disk) {
		return false
	}

	if !v.Ephemeral.Equal(other.Ephemeral) {
		return false
	}

	if !v.Gpu.Equal(other.Gpu) {
		return false
	}

	if !v.GpuCount.Equal(other.GpuCount) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Ram.Equal(other.Ram) {
		return false
	}

	return true
}

func (v FlavorValue) Type(ctx context.Context) attr.Type {
	return FlavorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FlavorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu":       basetypes.Int64Type{},
		"disk":      basetypes.Int64Type{},
		"ephemeral": basetypes.Int64Type{},
		"gpu":       basetypes.StringType{},
		"gpu_count": basetypes.Int64Type{},
		"id":        basetypes.Int64Type{},
		"name":      basetypes.StringType{},
		"ram":       basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = ImageType{}

type ImageType struct {
	basetypes.ObjectType
}

func (t ImageType) Equal(o attr.Type) bool {
	other, ok := o.(ImageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ImageType) String() string {
	return "ImageType"
}

func (t ImageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ImageValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewImageValueNull() ImageValue {
	return ImageValue{
		state: attr.ValueStateNull,
	}
}

func NewImageValueUnknown() ImageValue {
	return ImageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewImageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ImageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ImageValue Attribute Value",
				"While creating a ImageValue value, a missing attribute value was detected. "+
					"A ImageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ImageValue Attribute Type",
				"While creating a ImageValue value, an invalid attribute value was detected. "+
					"A ImageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ImageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ImageValue Attribute Value",
				"While creating a ImageValue value, an extra attribute value was detected. "+
					"A ImageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ImageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewImageValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewImageValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewImageValueUnknown(), diags
	}

	return ImageValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewImageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ImageValue {
	object, diags := NewImageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewImageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ImageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewImageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewImageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewImageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewImageValueMust(ImageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ImageType) ValueType(ctx context.Context) attr.Value {
	return ImageValue{}
}

var _ basetypes.ObjectValuable = ImageValue{}

type ImageValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v ImageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ImageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ImageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ImageValue) String() string {
	return "ImageValue"
}

func (v ImageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v ImageValue) Equal(o attr.Value) bool {
	other, ok := o.(ImageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ImageValue) Type(ctx context.Context) attr.Type {
	return ImageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ImageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = KeypairType{}

type KeypairType struct {
	basetypes.ObjectType
}

func (t KeypairType) Equal(o attr.Type) bool {
	other, ok := o.(KeypairType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KeypairType) String() string {
	return "KeypairType"
}

func (t KeypairType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KeypairValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewKeypairValueNull() KeypairValue {
	return KeypairValue{
		state: attr.ValueStateNull,
	}
}

func NewKeypairValueUnknown() KeypairValue {
	return KeypairValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKeypairValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KeypairValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KeypairValue Attribute Value",
				"While creating a KeypairValue value, a missing attribute value was detected. "+
					"A KeypairValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KeypairValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KeypairValue Attribute Type",
				"While creating a KeypairValue value, an invalid attribute value was detected. "+
					"A KeypairValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KeypairValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KeypairValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KeypairValue Attribute Value",
				"While creating a KeypairValue value, an extra attribute value was detected. "+
					"A KeypairValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KeypairValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKeypairValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewKeypairValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewKeypairValueUnknown(), diags
	}

	return KeypairValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewKeypairValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KeypairValue {
	object, diags := NewKeypairValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKeypairValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KeypairType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKeypairValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKeypairValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKeypairValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKeypairValueMust(KeypairValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KeypairType) ValueType(ctx context.Context) attr.Value {
	return KeypairValue{}
}

var _ basetypes.ObjectValuable = KeypairValue{}

type KeypairValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v KeypairValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KeypairValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KeypairValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KeypairValue) String() string {
	return "KeypairValue"
}

func (v KeypairValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v KeypairValue) Equal(o attr.Value) bool {
	other, ok := o.(KeypairValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v KeypairValue) Type(ctx context.Context) attr.Type {
	return KeypairType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KeypairValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityRulesType{}

type SecurityRulesType struct {
	basetypes.ObjectType
}

func (t SecurityRulesType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityRulesType) String() string {
	return "SecurityRulesType"
}

func (t SecurityRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return nil, diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return nil, diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	portRangeMaxAttribute, ok := attributes["port_range_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range_max is missing from object`)

		return nil, diags
	}

	portRangeMaxVal, ok := portRangeMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range_max expected to be basetypes.Int64Value, was: %T`, portRangeMaxAttribute))
	}

	portRangeMinAttribute, ok := attributes["port_range_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range_min is missing from object`)

		return nil, diags
	}

	portRangeMinVal, ok := portRangeMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range_min expected to be basetypes.Int64Value, was: %T`, portRangeMinAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	remoteIpPrefixAttribute, ok := attributes["remote_ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ip_prefix is missing from object`)

		return nil, diags
	}

	remoteIpPrefixVal, ok := remoteIpPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ip_prefix expected to be basetypes.StringValue, was: %T`, remoteIpPrefixAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	virtualMachineIdAttribute, ok := attributes["virtual_machine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_machine_id is missing from object`)

		return nil, diags
	}

	virtualMachineIdVal, ok := virtualMachineIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_machine_id expected to be basetypes.Int64Value, was: %T`, virtualMachineIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityRulesValue{
		CreatedAt:        createdAtVal,
		Direction:        directionVal,
		Ethertype:        ethertypeVal,
		Id:               idVal,
		PortRangeMax:     portRangeMaxVal,
		PortRangeMin:     portRangeMinVal,
		Protocol:         protocolVal,
		RemoteIpPrefix:   remoteIpPrefixVal,
		Status:           statusVal,
		VirtualMachineId: virtualMachineIdVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSecurityRulesValueNull() SecurityRulesValue {
	return SecurityRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityRulesValueUnknown() SecurityRulesValue {
	return SecurityRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityRulesValue Attribute Value",
				"While creating a SecurityRulesValue value, a missing attribute value was detected. "+
					"A SecurityRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityRulesValue Attribute Type",
				"While creating a SecurityRulesValue value, an invalid attribute value was detected. "+
					"A SecurityRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityRulesValue Attribute Value",
				"While creating a SecurityRulesValue value, an extra attribute value was detected. "+
					"A SecurityRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityRulesValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	portRangeMaxAttribute, ok := attributes["port_range_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range_max is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	portRangeMaxVal, ok := portRangeMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range_max expected to be basetypes.Int64Value, was: %T`, portRangeMaxAttribute))
	}

	portRangeMinAttribute, ok := attributes["port_range_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range_min is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	portRangeMinVal, ok := portRangeMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range_min expected to be basetypes.Int64Value, was: %T`, portRangeMinAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	remoteIpPrefixAttribute, ok := attributes["remote_ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ip_prefix is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	remoteIpPrefixVal, ok := remoteIpPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ip_prefix expected to be basetypes.StringValue, was: %T`, remoteIpPrefixAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	virtualMachineIdAttribute, ok := attributes["virtual_machine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_machine_id is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	virtualMachineIdVal, ok := virtualMachineIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_machine_id expected to be basetypes.Int64Value, was: %T`, virtualMachineIdAttribute))
	}

	if diags.HasError() {
		return NewSecurityRulesValueUnknown(), diags
	}

	return SecurityRulesValue{
		CreatedAt:        createdAtVal,
		Direction:        directionVal,
		Ethertype:        ethertypeVal,
		Id:               idVal,
		PortRangeMax:     portRangeMaxVal,
		PortRangeMin:     portRangeMinVal,
		Protocol:         protocolVal,
		RemoteIpPrefix:   remoteIpPrefixVal,
		Status:           statusVal,
		VirtualMachineId: virtualMachineIdVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSecurityRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityRulesValue {
	object, diags := NewSecurityRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityRulesValueMust(SecurityRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityRulesType) ValueType(ctx context.Context) attr.Value {
	return SecurityRulesValue{}
}

var _ basetypes.ObjectValuable = SecurityRulesValue{}

type SecurityRulesValue struct {
	CreatedAt        basetypes.StringValue `tfsdk:"created_at"`
	Direction        basetypes.StringValue `tfsdk:"direction"`
	Ethertype        basetypes.StringValue `tfsdk:"ethertype"`
	Id               basetypes.Int64Value  `tfsdk:"id"`
	PortRangeMax     basetypes.Int64Value  `tfsdk:"port_range_max"`
	PortRangeMin     basetypes.Int64Value  `tfsdk:"port_range_min"`
	Protocol         basetypes.StringValue `tfsdk:"protocol"`
	RemoteIpPrefix   basetypes.StringValue `tfsdk:"remote_ip_prefix"`
	Status           basetypes.StringValue `tfsdk:"status"`
	VirtualMachineId basetypes.Int64Value  `tfsdk:"virtual_machine_id"`
	state            attr.ValueState
}

func (v SecurityRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["direction"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ethertype"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["port_range_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["port_range_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["virtual_machine_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Direction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direction"] = val

		val, err = v.Ethertype.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethertype"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.PortRangeMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range_max"] = val

		val, err = v.PortRangeMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range_min"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.RemoteIpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ip_prefix"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.VirtualMachineId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["virtual_machine_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityRulesValue) String() string {
	return "SecurityRulesValue"
}

func (v SecurityRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created_at":         basetypes.StringType{},
		"direction":          basetypes.StringType{},
		"ethertype":          basetypes.StringType{},
		"id":                 basetypes.Int64Type{},
		"port_range_max":     basetypes.Int64Type{},
		"port_range_min":     basetypes.Int64Type{},
		"protocol":           basetypes.StringType{},
		"remote_ip_prefix":   basetypes.StringType{},
		"status":             basetypes.StringType{},
		"virtual_machine_id": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at":         v.CreatedAt,
			"direction":          v.Direction,
			"ethertype":          v.Ethertype,
			"id":                 v.Id,
			"port_range_max":     v.PortRangeMax,
			"port_range_min":     v.PortRangeMin,
			"protocol":           v.Protocol,
			"remote_ip_prefix":   v.RemoteIpPrefix,
			"status":             v.Status,
			"virtual_machine_id": v.VirtualMachineId,
		})

	return objVal, diags
}

func (v SecurityRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Direction.Equal(other.Direction) {
		return false
	}

	if !v.Ethertype.Equal(other.Ethertype) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.PortRangeMax.Equal(other.PortRangeMax) {
		return false
	}

	if !v.PortRangeMin.Equal(other.PortRangeMin) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.RemoteIpPrefix.Equal(other.RemoteIpPrefix) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.VirtualMachineId.Equal(other.VirtualMachineId) {
		return false
	}

	return true
}

func (v SecurityRulesValue) Type(ctx context.Context) attr.Type {
	return SecurityRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at":         basetypes.StringType{},
		"direction":          basetypes.StringType{},
		"ethertype":          basetypes.StringType{},
		"id":                 basetypes.Int64Type{},
		"port_range_max":     basetypes.Int64Type{},
		"port_range_min":     basetypes.Int64Type{},
		"protocol":           basetypes.StringType{},
		"remote_ip_prefix":   basetypes.StringType{},
		"status":             basetypes.StringType{},
		"virtual_machine_id": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VolumeAttachmentsType{}

type VolumeAttachmentsType struct {
	basetypes.ObjectType
}

func (t VolumeAttachmentsType) Equal(o attr.Type) bool {
	other, ok := o.(VolumeAttachmentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumeAttachmentsType) String() string {
	return "VolumeAttachmentsType"
}

func (t VolumeAttachmentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	deviceAttribute, ok := attributes["device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device is missing from object`)

		return nil, diags
	}

	deviceVal, ok := deviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device expected to be basetypes.StringValue, was: %T`, deviceAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return nil, diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.ObjectValue, was: %T`, volumeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumeAttachmentsValue{
		CreatedAt: createdAtVal,
		Device:    deviceVal,
		Status:    statusVal,
		Volume:    volumeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumeAttachmentsValueNull() VolumeAttachmentsValue {
	return VolumeAttachmentsValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumeAttachmentsValueUnknown() VolumeAttachmentsValue {
	return VolumeAttachmentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumeAttachmentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumeAttachmentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumeAttachmentsValue Attribute Value",
				"While creating a VolumeAttachmentsValue value, a missing attribute value was detected. "+
					"A VolumeAttachmentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeAttachmentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumeAttachmentsValue Attribute Type",
				"While creating a VolumeAttachmentsValue value, an invalid attribute value was detected. "+
					"A VolumeAttachmentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeAttachmentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumeAttachmentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumeAttachmentsValue Attribute Value",
				"While creating a VolumeAttachmentsValue value, an extra attribute value was detected. "+
					"A VolumeAttachmentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumeAttachmentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumeAttachmentsValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewVolumeAttachmentsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	deviceAttribute, ok := attributes["device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device is missing from object`)

		return NewVolumeAttachmentsValueUnknown(), diags
	}

	deviceVal, ok := deviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device expected to be basetypes.StringValue, was: %T`, deviceAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewVolumeAttachmentsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return NewVolumeAttachmentsValueUnknown(), diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.ObjectValue, was: %T`, volumeAttribute))
	}

	if diags.HasError() {
		return NewVolumeAttachmentsValueUnknown(), diags
	}

	return VolumeAttachmentsValue{
		CreatedAt: createdAtVal,
		Device:    deviceVal,
		Status:    statusVal,
		Volume:    volumeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumeAttachmentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumeAttachmentsValue {
	object, diags := NewVolumeAttachmentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumeAttachmentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumeAttachmentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumeAttachmentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumeAttachmentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumeAttachmentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumeAttachmentsValueMust(VolumeAttachmentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumeAttachmentsType) ValueType(ctx context.Context) attr.Value {
	return VolumeAttachmentsValue{}
}

var _ basetypes.ObjectValuable = VolumeAttachmentsValue{}

type VolumeAttachmentsValue struct {
	CreatedAt basetypes.StringValue `tfsdk:"created_at"`
	Device    basetypes.StringValue `tfsdk:"device"`
	Status    basetypes.StringValue `tfsdk:"status"`
	Volume    basetypes.ObjectValue `tfsdk:"volume"`
	state     attr.ValueState
}

func (v VolumeAttachmentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["device"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume"] = basetypes.ObjectType{
		AttrTypes: VolumeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Device.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Volume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumeAttachmentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumeAttachmentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumeAttachmentsValue) String() string {
	return "VolumeAttachmentsValue"
}

func (v VolumeAttachmentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var volume basetypes.ObjectValue

	if v.Volume.IsNull() {
		volume = types.ObjectNull(
			VolumeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Volume.IsUnknown() {
		volume = types.ObjectUnknown(
			VolumeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Volume.IsNull() && !v.Volume.IsUnknown() {
		volume = types.ObjectValueMust(
			VolumeValue{}.AttributeTypes(ctx),
			v.Volume.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"device":     basetypes.StringType{},
		"status":     basetypes.StringType{},
		"volume": basetypes.ObjectType{
			AttrTypes: VolumeValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at": v.CreatedAt,
			"device":     v.Device,
			"status":     v.Status,
			"volume":     volume,
		})

	return objVal, diags
}

func (v VolumeAttachmentsValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumeAttachmentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Device.Equal(other.Device) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Volume.Equal(other.Volume) {
		return false
	}

	return true
}

func (v VolumeAttachmentsValue) Type(ctx context.Context) attr.Type {
	return VolumeAttachmentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumeAttachmentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"device":     basetypes.StringType{},
		"status":     basetypes.StringType{},
		"volume": basetypes.ObjectType{
			AttrTypes: VolumeValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = VolumeType{}

type VolumeType struct {
	basetypes.ObjectType
}

func (t VolumeType) Equal(o attr.Type) bool {
	other, ok := o.(VolumeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumeType) String() string {
	return "VolumeType"
}

func (t VolumeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumeValue{
		Description: descriptionVal,
		Id:          idVal,
		Name:        nameVal,
		Size:        sizeVal,
		VolumeType:  volumeTypeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVolumeValueNull() VolumeValue {
	return VolumeValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumeValueUnknown() VolumeValue {
	return VolumeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumeValue Attribute Value",
				"While creating a VolumeValue value, a missing attribute value was detected. "+
					"A VolumeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumeValue Attribute Type",
				"While creating a VolumeValue value, an invalid attribute value was detected. "+
					"A VolumeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumeValue Attribute Value",
				"While creating a VolumeValue value, an extra attribute value was detected. "+
					"A VolumeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumeValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewVolumeValueUnknown(), diags
	}

	return VolumeValue{
		Description: descriptionVal,
		Id:          idVal,
		Name:        nameVal,
		Size:        sizeVal,
		VolumeType:  volumeTypeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVolumeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumeValue {
	object, diags := NewVolumeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumeValueMust(VolumeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumeType) ValueType(ctx context.Context) attr.Value {
	return VolumeValue{}
}

var _ basetypes.ObjectValuable = VolumeValue{}

type VolumeValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Size        basetypes.Int64Value  `tfsdk:"size"`
	VolumeType  basetypes.StringValue `tfsdk:"volume_type"`
	state       attr.ValueState
}

func (v VolumeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumeValue) String() string {
	return "VolumeValue"
}

func (v VolumeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"size":        basetypes.Int64Type{},
		"volume_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"id":          v.Id,
			"name":        v.Name,
			"size":        v.Size,
			"volume_type": v.VolumeType,
		})

	return objVal, diags
}

func (v VolumeValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v VolumeValue) Type(ctx context.Context) attr.Type {
	return VolumeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"size":        basetypes.Int64Type{},
		"volume_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ProfileType{}

type ProfileType struct {
	basetypes.ObjectType
}

func (t ProfileType) Equal(o attr.Type) bool {
	other, ok := o.(ProfileType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProfileType) String() string {
	return "ProfileType"
}

func (t ProfileType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProfileValue{
		Description: descriptionVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewProfileValueNull() ProfileValue {
	return ProfileValue{
		state: attr.ValueStateNull,
	}
}

func NewProfileValueUnknown() ProfileValue {
	return ProfileValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProfileValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProfileValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProfileValue Attribute Value",
				"While creating a ProfileValue value, a missing attribute value was detected. "+
					"A ProfileValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProfileValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProfileValue Attribute Type",
				"While creating a ProfileValue value, an invalid attribute value was detected. "+
					"A ProfileValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProfileValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProfileValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProfileValue Attribute Value",
				"While creating a ProfileValue value, an extra attribute value was detected. "+
					"A ProfileValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProfileValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProfileValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewProfileValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewProfileValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewProfileValueUnknown(), diags
	}

	return ProfileValue{
		Description: descriptionVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewProfileValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProfileValue {
	object, diags := NewProfileValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProfileValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProfileType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProfileValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProfileValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProfileValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProfileValueMust(ProfileValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProfileType) ValueType(ctx context.Context) attr.Value {
	return ProfileValue{}
}

var _ basetypes.ObjectValuable = ProfileValue{}

type ProfileValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Name        basetypes.StringValue `tfsdk:"name"`
	state       attr.ValueState
}

func (v ProfileValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProfileValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProfileValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProfileValue) String() string {
	return "ProfileValue"
}

func (v ProfileValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"name":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"name":        v.Name,
		})

	return objVal, diags
}

func (v ProfileValue) Equal(o attr.Value) bool {
	other, ok := o.(ProfileValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ProfileValue) Type(ctx context.Context) attr.Type {
	return ProfileType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProfileValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"name":        basetypes.StringType{},
	}
}
