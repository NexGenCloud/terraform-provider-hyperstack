// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_core_virtual_machines

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func CoreVirtualMachinesDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"core_virtual_machines": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"callback_url": schema.StringAttribute{
							Computed: true,
						},
						"contract_id": schema.Int64Attribute{
							Computed: true,
						},
						"created_at": schema.StringAttribute{
							Computed: true,
						},
						"environment": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"features": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"network_optimised": schema.BoolAttribute{
											Computed: true,
										},
									},
									CustomType: FeaturesType{
										ObjectType: types.ObjectType{
											AttrTypes: FeaturesValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"org_id": schema.Int64Attribute{
									Computed: true,
								},
								"region": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: EnvironmentType{
								ObjectType: types.ObjectType{
									AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"fixed_ip": schema.StringAttribute{
							Computed: true,
						},
						"flavor": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"cpu": schema.Int64Attribute{
									Computed: true,
								},
								"disk": schema.Int64Attribute{
									Computed: true,
								},
								"ephemeral": schema.Int64Attribute{
									Computed: true,
								},
								"gpu": schema.StringAttribute{
									Computed: true,
								},
								"gpu_count": schema.Int64Attribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"ram": schema.NumberAttribute{
									Computed: true,
								},
							},
							CustomType: FlavorType{
								ObjectType: types.ObjectType{
									AttrTypes: FlavorValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"floating_ip": schema.StringAttribute{
							Computed: true,
						},
						"floating_ip_status": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.Int64Attribute{
							Computed: true,
						},
						"image": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: ImageType{
								ObjectType: types.ObjectType{
									AttrTypes: ImageValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"keypair": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: KeypairType{
								ObjectType: types.ObjectType{
									AttrTypes: KeypairValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"labels": schema.ListAttribute{
							ElementType: types.StringType,
							Computed:    true,
						},
						"locked": schema.BoolAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"os": schema.StringAttribute{
							Computed: true,
						},
						"port_randomization": schema.BoolAttribute{
							Computed: true,
						},
						"port_randomization_status": schema.StringAttribute{
							Computed: true,
						},
						"power_state": schema.StringAttribute{
							Computed: true,
						},
						"security_rules": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"created_at": schema.StringAttribute{
										Computed: true,
									},
									"direction": schema.StringAttribute{
										Computed: true,
									},
									"ethertype": schema.StringAttribute{
										Computed: true,
									},
									"id": schema.Int64Attribute{
										Computed: true,
									},
									"port_range_max": schema.Int64Attribute{
										Computed: true,
									},
									"port_range_min": schema.Int64Attribute{
										Computed: true,
									},
									"protocol": schema.StringAttribute{
										Computed: true,
									},
									"remote_ip_prefix": schema.StringAttribute{
										Computed: true,
									},
									"status": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SecurityRulesType{
									ObjectType: types.ObjectType{
										AttrTypes: SecurityRulesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"status": schema.StringAttribute{
							Computed: true,
						},
						"vm_state": schema.StringAttribute{
							Computed: true,
						},
						"volume_attachments": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"created_at": schema.StringAttribute{
										Computed: true,
									},
									"device": schema.StringAttribute{
										Computed: true,
									},
									"status": schema.StringAttribute{
										Computed: true,
									},
									"volume": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"bootable": schema.BoolAttribute{
												Computed: true,
											},
											"description": schema.StringAttribute{
												Computed: true,
											},
											"id": schema.Int64Attribute{
												Computed: true,
											},
											"name": schema.StringAttribute{
												Computed: true,
											},
											"size": schema.Int64Attribute{
												Computed: true,
											},
											"volume_type": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: VolumeType{
											ObjectType: types.ObjectType{
												AttrTypes: VolumeValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
								},
								CustomType: VolumeAttachmentsType{
									ObjectType: types.ObjectType{
										AttrTypes: VolumeAttachmentsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
					},
					CustomType: CoreVirtualMachinesType{
						ObjectType: types.ObjectType{
							AttrTypes: CoreVirtualMachinesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"environment": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Filter Environment ID or Name",
				MarkdownDescription: "Filter Environment ID or Name",
			},
			"page": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Page Number",
				MarkdownDescription: "Page Number",
			},
			"page_size": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Data Per Page",
				MarkdownDescription: "Data Per Page",
			},
			"search": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
		},
	}
}

type CoreVirtualMachinesModel struct {
	CoreVirtualMachines types.Set    `tfsdk:"core_virtual_machines"`
	Environment         types.String `tfsdk:"environment"`
	Page                types.String `tfsdk:"page"`
	PageSize            types.String `tfsdk:"page_size"`
	Search              types.String `tfsdk:"search"`
}

var _ basetypes.ObjectTypable = CoreVirtualMachinesType{}

type CoreVirtualMachinesType struct {
	basetypes.ObjectType
}

func (t CoreVirtualMachinesType) Equal(o attr.Type) bool {
	other, ok := o.(CoreVirtualMachinesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CoreVirtualMachinesType) String() string {
	return "CoreVirtualMachinesType"
}

func (t CoreVirtualMachinesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	callbackUrlAttribute, ok := attributes["callback_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`callback_url is missing from object`)

		return nil, diags
	}

	callbackUrlVal, ok := callbackUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`callback_url expected to be basetypes.StringValue, was: %T`, callbackUrlAttribute))
	}

	contractIdAttribute, ok := attributes["contract_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contract_id is missing from object`)

		return nil, diags
	}

	contractIdVal, ok := contractIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contract_id expected to be basetypes.Int64Value, was: %T`, contractIdAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	environmentAttribute, ok := attributes["environment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`environment is missing from object`)

		return nil, diags
	}

	environmentVal, ok := environmentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`environment expected to be basetypes.ObjectValue, was: %T`, environmentAttribute))
	}

	fixedIpAttribute, ok := attributes["fixed_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ip is missing from object`)

		return nil, diags
	}

	fixedIpVal, ok := fixedIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ip expected to be basetypes.StringValue, was: %T`, fixedIpAttribute))
	}

	flavorAttribute, ok := attributes["flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor is missing from object`)

		return nil, diags
	}

	flavorVal, ok := flavorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor expected to be basetypes.ObjectValue, was: %T`, flavorAttribute))
	}

	floatingIpAttribute, ok := attributes["floating_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip is missing from object`)

		return nil, diags
	}

	floatingIpVal, ok := floatingIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip expected to be basetypes.StringValue, was: %T`, floatingIpAttribute))
	}

	floatingIpStatusAttribute, ok := attributes["floating_ip_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip_status is missing from object`)

		return nil, diags
	}

	floatingIpStatusVal, ok := floatingIpStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip_status expected to be basetypes.StringValue, was: %T`, floatingIpStatusAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.ObjectValue, was: %T`, imageAttribute))
	}

	keypairAttribute, ok := attributes["keypair"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keypair is missing from object`)

		return nil, diags
	}

	keypairVal, ok := keypairAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keypair expected to be basetypes.ObjectValue, was: %T`, keypairAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.ListValue, was: %T`, labelsAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return nil, diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	osAttribute, ok := attributes["os"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`os is missing from object`)

		return nil, diags
	}

	osVal, ok := osAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`os expected to be basetypes.StringValue, was: %T`, osAttribute))
	}

	portRandomizationAttribute, ok := attributes["port_randomization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_randomization is missing from object`)

		return nil, diags
	}

	portRandomizationVal, ok := portRandomizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_randomization expected to be basetypes.BoolValue, was: %T`, portRandomizationAttribute))
	}

	portRandomizationStatusAttribute, ok := attributes["port_randomization_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_randomization_status is missing from object`)

		return nil, diags
	}

	portRandomizationStatusVal, ok := portRandomizationStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_randomization_status expected to be basetypes.StringValue, was: %T`, portRandomizationStatusAttribute))
	}

	powerStateAttribute, ok := attributes["power_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_state is missing from object`)

		return nil, diags
	}

	powerStateVal, ok := powerStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_state expected to be basetypes.StringValue, was: %T`, powerStateAttribute))
	}

	securityRulesAttribute, ok := attributes["security_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_rules is missing from object`)

		return nil, diags
	}

	securityRulesVal, ok := securityRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_rules expected to be basetypes.ListValue, was: %T`, securityRulesAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	vmStateAttribute, ok := attributes["vm_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vm_state is missing from object`)

		return nil, diags
	}

	vmStateVal, ok := vmStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vm_state expected to be basetypes.StringValue, was: %T`, vmStateAttribute))
	}

	volumeAttachmentsAttribute, ok := attributes["volume_attachments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_attachments is missing from object`)

		return nil, diags
	}

	volumeAttachmentsVal, ok := volumeAttachmentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_attachments expected to be basetypes.ListValue, was: %T`, volumeAttachmentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CoreVirtualMachinesValue{
		CallbackUrl:             callbackUrlVal,
		ContractId:              contractIdVal,
		CreatedAt:               createdAtVal,
		Environment:             environmentVal,
		FixedIp:                 fixedIpVal,
		Flavor:                  flavorVal,
		FloatingIp:              floatingIpVal,
		FloatingIpStatus:        floatingIpStatusVal,
		Id:                      idVal,
		Image:                   imageVal,
		Keypair:                 keypairVal,
		Labels:                  labelsVal,
		Locked:                  lockedVal,
		Name:                    nameVal,
		Os:                      osVal,
		PortRandomization:       portRandomizationVal,
		PortRandomizationStatus: portRandomizationStatusVal,
		PowerState:              powerStateVal,
		SecurityRules:           securityRulesVal,
		Status:                  statusVal,
		VmState:                 vmStateVal,
		VolumeAttachments:       volumeAttachmentsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewCoreVirtualMachinesValueNull() CoreVirtualMachinesValue {
	return CoreVirtualMachinesValue{
		state: attr.ValueStateNull,
	}
}

func NewCoreVirtualMachinesValueUnknown() CoreVirtualMachinesValue {
	return CoreVirtualMachinesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCoreVirtualMachinesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CoreVirtualMachinesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CoreVirtualMachinesValue Attribute Value",
				"While creating a CoreVirtualMachinesValue value, a missing attribute value was detected. "+
					"A CoreVirtualMachinesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CoreVirtualMachinesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CoreVirtualMachinesValue Attribute Type",
				"While creating a CoreVirtualMachinesValue value, an invalid attribute value was detected. "+
					"A CoreVirtualMachinesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CoreVirtualMachinesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CoreVirtualMachinesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CoreVirtualMachinesValue Attribute Value",
				"While creating a CoreVirtualMachinesValue value, an extra attribute value was detected. "+
					"A CoreVirtualMachinesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CoreVirtualMachinesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	callbackUrlAttribute, ok := attributes["callback_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`callback_url is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	callbackUrlVal, ok := callbackUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`callback_url expected to be basetypes.StringValue, was: %T`, callbackUrlAttribute))
	}

	contractIdAttribute, ok := attributes["contract_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contract_id is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	contractIdVal, ok := contractIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contract_id expected to be basetypes.Int64Value, was: %T`, contractIdAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	environmentAttribute, ok := attributes["environment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`environment is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	environmentVal, ok := environmentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`environment expected to be basetypes.ObjectValue, was: %T`, environmentAttribute))
	}

	fixedIpAttribute, ok := attributes["fixed_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ip is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	fixedIpVal, ok := fixedIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ip expected to be basetypes.StringValue, was: %T`, fixedIpAttribute))
	}

	flavorAttribute, ok := attributes["flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	flavorVal, ok := flavorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor expected to be basetypes.ObjectValue, was: %T`, flavorAttribute))
	}

	floatingIpAttribute, ok := attributes["floating_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	floatingIpVal, ok := floatingIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip expected to be basetypes.StringValue, was: %T`, floatingIpAttribute))
	}

	floatingIpStatusAttribute, ok := attributes["floating_ip_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip_status is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	floatingIpStatusVal, ok := floatingIpStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip_status expected to be basetypes.StringValue, was: %T`, floatingIpStatusAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.ObjectValue, was: %T`, imageAttribute))
	}

	keypairAttribute, ok := attributes["keypair"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keypair is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	keypairVal, ok := keypairAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keypair expected to be basetypes.ObjectValue, was: %T`, keypairAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.ListValue, was: %T`, labelsAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	osAttribute, ok := attributes["os"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`os is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	osVal, ok := osAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`os expected to be basetypes.StringValue, was: %T`, osAttribute))
	}

	portRandomizationAttribute, ok := attributes["port_randomization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_randomization is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	portRandomizationVal, ok := portRandomizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_randomization expected to be basetypes.BoolValue, was: %T`, portRandomizationAttribute))
	}

	portRandomizationStatusAttribute, ok := attributes["port_randomization_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_randomization_status is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	portRandomizationStatusVal, ok := portRandomizationStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_randomization_status expected to be basetypes.StringValue, was: %T`, portRandomizationStatusAttribute))
	}

	powerStateAttribute, ok := attributes["power_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_state is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	powerStateVal, ok := powerStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_state expected to be basetypes.StringValue, was: %T`, powerStateAttribute))
	}

	securityRulesAttribute, ok := attributes["security_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_rules is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	securityRulesVal, ok := securityRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_rules expected to be basetypes.ListValue, was: %T`, securityRulesAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	vmStateAttribute, ok := attributes["vm_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vm_state is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	vmStateVal, ok := vmStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vm_state expected to be basetypes.StringValue, was: %T`, vmStateAttribute))
	}

	volumeAttachmentsAttribute, ok := attributes["volume_attachments"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_attachments is missing from object`)

		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	volumeAttachmentsVal, ok := volumeAttachmentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_attachments expected to be basetypes.ListValue, was: %T`, volumeAttachmentsAttribute))
	}

	if diags.HasError() {
		return NewCoreVirtualMachinesValueUnknown(), diags
	}

	return CoreVirtualMachinesValue{
		CallbackUrl:             callbackUrlVal,
		ContractId:              contractIdVal,
		CreatedAt:               createdAtVal,
		Environment:             environmentVal,
		FixedIp:                 fixedIpVal,
		Flavor:                  flavorVal,
		FloatingIp:              floatingIpVal,
		FloatingIpStatus:        floatingIpStatusVal,
		Id:                      idVal,
		Image:                   imageVal,
		Keypair:                 keypairVal,
		Labels:                  labelsVal,
		Locked:                  lockedVal,
		Name:                    nameVal,
		Os:                      osVal,
		PortRandomization:       portRandomizationVal,
		PortRandomizationStatus: portRandomizationStatusVal,
		PowerState:              powerStateVal,
		SecurityRules:           securityRulesVal,
		Status:                  statusVal,
		VmState:                 vmStateVal,
		VolumeAttachments:       volumeAttachmentsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewCoreVirtualMachinesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CoreVirtualMachinesValue {
	object, diags := NewCoreVirtualMachinesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCoreVirtualMachinesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CoreVirtualMachinesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCoreVirtualMachinesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCoreVirtualMachinesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCoreVirtualMachinesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCoreVirtualMachinesValueMust(CoreVirtualMachinesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CoreVirtualMachinesType) ValueType(ctx context.Context) attr.Value {
	return CoreVirtualMachinesValue{}
}

var _ basetypes.ObjectValuable = CoreVirtualMachinesValue{}

type CoreVirtualMachinesValue struct {
	CallbackUrl             basetypes.StringValue `tfsdk:"callback_url"`
	ContractId              basetypes.Int64Value  `tfsdk:"contract_id"`
	CreatedAt               basetypes.StringValue `tfsdk:"created_at"`
	Environment             basetypes.ObjectValue `tfsdk:"environment"`
	FixedIp                 basetypes.StringValue `tfsdk:"fixed_ip"`
	Flavor                  basetypes.ObjectValue `tfsdk:"flavor"`
	FloatingIp              basetypes.StringValue `tfsdk:"floating_ip"`
	FloatingIpStatus        basetypes.StringValue `tfsdk:"floating_ip_status"`
	Id                      basetypes.Int64Value  `tfsdk:"id"`
	Image                   basetypes.ObjectValue `tfsdk:"image"`
	Keypair                 basetypes.ObjectValue `tfsdk:"keypair"`
	Labels                  basetypes.ListValue   `tfsdk:"labels"`
	Locked                  basetypes.BoolValue   `tfsdk:"locked"`
	Name                    basetypes.StringValue `tfsdk:"name"`
	Os                      basetypes.StringValue `tfsdk:"os"`
	PortRandomization       basetypes.BoolValue   `tfsdk:"port_randomization"`
	PortRandomizationStatus basetypes.StringValue `tfsdk:"port_randomization_status"`
	PowerState              basetypes.StringValue `tfsdk:"power_state"`
	SecurityRules           basetypes.ListValue   `tfsdk:"security_rules"`
	Status                  basetypes.StringValue `tfsdk:"status"`
	VmState                 basetypes.StringValue `tfsdk:"vm_state"`
	VolumeAttachments       basetypes.ListValue   `tfsdk:"volume_attachments"`
	state                   attr.ValueState
}

func (v CoreVirtualMachinesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 22)

	var val tftypes.Value
	var err error

	attrTypes["callback_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["contract_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["environment"] = basetypes.ObjectType{
		AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["fixed_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["flavor"] = basetypes.ObjectType{
		AttrTypes: FlavorValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["floating_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["floating_ip_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["image"] = basetypes.ObjectType{
		AttrTypes: ImageValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["keypair"] = basetypes.ObjectType{
		AttrTypes: KeypairValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["locked"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["os"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_randomization"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_randomization_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_rules"] = basetypes.ListType{
		ElemType: SecurityRulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vm_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_attachments"] = basetypes.ListType{
		ElemType: VolumeAttachmentsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 22)

		val, err = v.CallbackUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["callback_url"] = val

		val, err = v.ContractId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contract_id"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Environment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["environment"] = val

		val, err = v.FixedIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_ip"] = val

		val, err = v.Flavor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flavor"] = val

		val, err = v.FloatingIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["floating_ip"] = val

		val, err = v.FloatingIpStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["floating_ip_status"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.Keypair.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keypair"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Locked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locked"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Os.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["os"] = val

		val, err = v.PortRandomization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_randomization"] = val

		val, err = v.PortRandomizationStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_randomization_status"] = val

		val, err = v.PowerState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_state"] = val

		val, err = v.SecurityRules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_rules"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.VmState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vm_state"] = val

		val, err = v.VolumeAttachments.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_attachments"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CoreVirtualMachinesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CoreVirtualMachinesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CoreVirtualMachinesValue) String() string {
	return "CoreVirtualMachinesValue"
}

func (v CoreVirtualMachinesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var environment basetypes.ObjectValue

	if v.Environment.IsNull() {
		environment = types.ObjectNull(
			EnvironmentValue{}.AttributeTypes(ctx),
		)
	}

	if v.Environment.IsUnknown() {
		environment = types.ObjectUnknown(
			EnvironmentValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Environment.IsNull() && !v.Environment.IsUnknown() {
		environment = types.ObjectValueMust(
			EnvironmentValue{}.AttributeTypes(ctx),
			v.Environment.Attributes(),
		)
	}

	var flavor basetypes.ObjectValue

	if v.Flavor.IsNull() {
		flavor = types.ObjectNull(
			FlavorValue{}.AttributeTypes(ctx),
		)
	}

	if v.Flavor.IsUnknown() {
		flavor = types.ObjectUnknown(
			FlavorValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Flavor.IsNull() && !v.Flavor.IsUnknown() {
		flavor = types.ObjectValueMust(
			FlavorValue{}.AttributeTypes(ctx),
			v.Flavor.Attributes(),
		)
	}

	var image basetypes.ObjectValue

	if v.Image.IsNull() {
		image = types.ObjectNull(
			ImageValue{}.AttributeTypes(ctx),
		)
	}

	if v.Image.IsUnknown() {
		image = types.ObjectUnknown(
			ImageValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Image.IsNull() && !v.Image.IsUnknown() {
		image = types.ObjectValueMust(
			ImageValue{}.AttributeTypes(ctx),
			v.Image.Attributes(),
		)
	}

	var keypair basetypes.ObjectValue

	if v.Keypair.IsNull() {
		keypair = types.ObjectNull(
			KeypairValue{}.AttributeTypes(ctx),
		)
	}

	if v.Keypair.IsUnknown() {
		keypair = types.ObjectUnknown(
			KeypairValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Keypair.IsNull() && !v.Keypair.IsUnknown() {
		keypair = types.ObjectValueMust(
			KeypairValue{}.AttributeTypes(ctx),
			v.Keypair.Attributes(),
		)
	}

	securityRules := types.ListValueMust(
		SecurityRulesType{
			basetypes.ObjectType{
				AttrTypes: SecurityRulesValue{}.AttributeTypes(ctx),
			},
		},
		v.SecurityRules.Elements(),
	)

	if v.SecurityRules.IsNull() {
		securityRules = types.ListNull(
			SecurityRulesType{
				basetypes.ObjectType{
					AttrTypes: SecurityRulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityRules.IsUnknown() {
		securityRules = types.ListUnknown(
			SecurityRulesType{
				basetypes.ObjectType{
					AttrTypes: SecurityRulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	volumeAttachments := types.ListValueMust(
		VolumeAttachmentsType{
			basetypes.ObjectType{
				AttrTypes: VolumeAttachmentsValue{}.AttributeTypes(ctx),
			},
		},
		v.VolumeAttachments.Elements(),
	)

	if v.VolumeAttachments.IsNull() {
		volumeAttachments = types.ListNull(
			VolumeAttachmentsType{
				basetypes.ObjectType{
					AttrTypes: VolumeAttachmentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VolumeAttachments.IsUnknown() {
		volumeAttachments = types.ListUnknown(
			VolumeAttachmentsType{
				basetypes.ObjectType{
					AttrTypes: VolumeAttachmentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	labelsVal, d := types.ListValue(types.StringType, v.Labels.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"callback_url": basetypes.StringType{},
			"contract_id":  basetypes.Int64Type{},
			"created_at":   basetypes.StringType{},
			"environment": basetypes.ObjectType{
				AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
			},
			"fixed_ip": basetypes.StringType{},
			"flavor": basetypes.ObjectType{
				AttrTypes: FlavorValue{}.AttributeTypes(ctx),
			},
			"floating_ip":        basetypes.StringType{},
			"floating_ip_status": basetypes.StringType{},
			"id":                 basetypes.Int64Type{},
			"image": basetypes.ObjectType{
				AttrTypes: ImageValue{}.AttributeTypes(ctx),
			},
			"keypair": basetypes.ObjectType{
				AttrTypes: KeypairValue{}.AttributeTypes(ctx),
			},
			"labels": basetypes.ListType{
				ElemType: types.StringType,
			},
			"locked":                    basetypes.BoolType{},
			"name":                      basetypes.StringType{},
			"os":                        basetypes.StringType{},
			"port_randomization":        basetypes.BoolType{},
			"port_randomization_status": basetypes.StringType{},
			"power_state":               basetypes.StringType{},
			"security_rules": basetypes.ListType{
				ElemType: SecurityRulesValue{}.Type(ctx),
			},
			"status":   basetypes.StringType{},
			"vm_state": basetypes.StringType{},
			"volume_attachments": basetypes.ListType{
				ElemType: VolumeAttachmentsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"callback_url": basetypes.StringType{},
		"contract_id":  basetypes.Int64Type{},
		"created_at":   basetypes.StringType{},
		"environment": basetypes.ObjectType{
			AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
		},
		"fixed_ip": basetypes.StringType{},
		"flavor": basetypes.ObjectType{
			AttrTypes: FlavorValue{}.AttributeTypes(ctx),
		},
		"floating_ip":        basetypes.StringType{},
		"floating_ip_status": basetypes.StringType{},
		"id":                 basetypes.Int64Type{},
		"image": basetypes.ObjectType{
			AttrTypes: ImageValue{}.AttributeTypes(ctx),
		},
		"keypair": basetypes.ObjectType{
			AttrTypes: KeypairValue{}.AttributeTypes(ctx),
		},
		"labels": basetypes.ListType{
			ElemType: types.StringType,
		},
		"locked":                    basetypes.BoolType{},
		"name":                      basetypes.StringType{},
		"os":                        basetypes.StringType{},
		"port_randomization":        basetypes.BoolType{},
		"port_randomization_status": basetypes.StringType{},
		"power_state":               basetypes.StringType{},
		"security_rules": basetypes.ListType{
			ElemType: SecurityRulesValue{}.Type(ctx),
		},
		"status":   basetypes.StringType{},
		"vm_state": basetypes.StringType{},
		"volume_attachments": basetypes.ListType{
			ElemType: VolumeAttachmentsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"callback_url":              v.CallbackUrl,
			"contract_id":               v.ContractId,
			"created_at":                v.CreatedAt,
			"environment":               environment,
			"fixed_ip":                  v.FixedIp,
			"flavor":                    flavor,
			"floating_ip":               v.FloatingIp,
			"floating_ip_status":        v.FloatingIpStatus,
			"id":                        v.Id,
			"image":                     image,
			"keypair":                   keypair,
			"labels":                    labelsVal,
			"locked":                    v.Locked,
			"name":                      v.Name,
			"os":                        v.Os,
			"port_randomization":        v.PortRandomization,
			"port_randomization_status": v.PortRandomizationStatus,
			"power_state":               v.PowerState,
			"security_rules":            securityRules,
			"status":                    v.Status,
			"vm_state":                  v.VmState,
			"volume_attachments":        volumeAttachments,
		})

	return objVal, diags
}

func (v CoreVirtualMachinesValue) Equal(o attr.Value) bool {
	other, ok := o.(CoreVirtualMachinesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CallbackUrl.Equal(other.CallbackUrl) {
		return false
	}

	if !v.ContractId.Equal(other.ContractId) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Environment.Equal(other.Environment) {
		return false
	}

	if !v.FixedIp.Equal(other.FixedIp) {
		return false
	}

	if !v.Flavor.Equal(other.Flavor) {
		return false
	}

	if !v.FloatingIp.Equal(other.FloatingIp) {
		return false
	}

	if !v.FloatingIpStatus.Equal(other.FloatingIpStatus) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.Keypair.Equal(other.Keypair) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Locked.Equal(other.Locked) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Os.Equal(other.Os) {
		return false
	}

	if !v.PortRandomization.Equal(other.PortRandomization) {
		return false
	}

	if !v.PortRandomizationStatus.Equal(other.PortRandomizationStatus) {
		return false
	}

	if !v.PowerState.Equal(other.PowerState) {
		return false
	}

	if !v.SecurityRules.Equal(other.SecurityRules) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.VmState.Equal(other.VmState) {
		return false
	}

	if !v.VolumeAttachments.Equal(other.VolumeAttachments) {
		return false
	}

	return true
}

func (v CoreVirtualMachinesValue) Type(ctx context.Context) attr.Type {
	return CoreVirtualMachinesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CoreVirtualMachinesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"callback_url": basetypes.StringType{},
		"contract_id":  basetypes.Int64Type{},
		"created_at":   basetypes.StringType{},
		"environment": basetypes.ObjectType{
			AttrTypes: EnvironmentValue{}.AttributeTypes(ctx),
		},
		"fixed_ip": basetypes.StringType{},
		"flavor": basetypes.ObjectType{
			AttrTypes: FlavorValue{}.AttributeTypes(ctx),
		},
		"floating_ip":        basetypes.StringType{},
		"floating_ip_status": basetypes.StringType{},
		"id":                 basetypes.Int64Type{},
		"image": basetypes.ObjectType{
			AttrTypes: ImageValue{}.AttributeTypes(ctx),
		},
		"keypair": basetypes.ObjectType{
			AttrTypes: KeypairValue{}.AttributeTypes(ctx),
		},
		"labels": basetypes.ListType{
			ElemType: types.StringType,
		},
		"locked":                    basetypes.BoolType{},
		"name":                      basetypes.StringType{},
		"os":                        basetypes.StringType{},
		"port_randomization":        basetypes.BoolType{},
		"port_randomization_status": basetypes.StringType{},
		"power_state":               basetypes.StringType{},
		"security_rules": basetypes.ListType{
			ElemType: SecurityRulesValue{}.Type(ctx),
		},
		"status":   basetypes.StringType{},
		"vm_state": basetypes.StringType{},
		"volume_attachments": basetypes.ListType{
			ElemType: VolumeAttachmentsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = EnvironmentType{}

type EnvironmentType struct {
	basetypes.ObjectType
}

func (t EnvironmentType) Equal(o attr.Type) bool {
	other, ok := o.(EnvironmentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EnvironmentType) String() string {
	return "EnvironmentType"
}

func (t EnvironmentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return nil, diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ObjectValue, was: %T`, featuresAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.Int64Value, was: %T`, orgIdAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EnvironmentValue{
		Features: featuresVal,
		Id:       idVal,
		Name:     nameVal,
		OrgId:    orgIdVal,
		Region:   regionVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewEnvironmentValueNull() EnvironmentValue {
	return EnvironmentValue{
		state: attr.ValueStateNull,
	}
}

func NewEnvironmentValueUnknown() EnvironmentValue {
	return EnvironmentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEnvironmentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EnvironmentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EnvironmentValue Attribute Value",
				"While creating a EnvironmentValue value, a missing attribute value was detected. "+
					"A EnvironmentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvironmentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EnvironmentValue Attribute Type",
				"While creating a EnvironmentValue value, an invalid attribute value was detected. "+
					"A EnvironmentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvironmentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EnvironmentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EnvironmentValue Attribute Value",
				"While creating a EnvironmentValue value, an extra attribute value was detected. "+
					"A EnvironmentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EnvironmentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEnvironmentValueUnknown(), diags
	}

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ObjectValue, was: %T`, featuresAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.Int64Value, was: %T`, orgIdAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewEnvironmentValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return NewEnvironmentValueUnknown(), diags
	}

	return EnvironmentValue{
		Features: featuresVal,
		Id:       idVal,
		Name:     nameVal,
		OrgId:    orgIdVal,
		Region:   regionVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewEnvironmentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EnvironmentValue {
	object, diags := NewEnvironmentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEnvironmentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EnvironmentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEnvironmentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEnvironmentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEnvironmentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEnvironmentValueMust(EnvironmentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EnvironmentType) ValueType(ctx context.Context) attr.Value {
	return EnvironmentValue{}
}

var _ basetypes.ObjectValuable = EnvironmentValue{}

type EnvironmentValue struct {
	Features basetypes.ObjectValue `tfsdk:"features"`
	Id       basetypes.Int64Value  `tfsdk:"id"`
	Name     basetypes.StringValue `tfsdk:"name"`
	OrgId    basetypes.Int64Value  `tfsdk:"org_id"`
	Region   basetypes.StringValue `tfsdk:"region"`
	state    attr.ValueState
}

func (v EnvironmentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["features"] = basetypes.ObjectType{
		AttrTypes: FeaturesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Features.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["features"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EnvironmentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EnvironmentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EnvironmentValue) String() string {
	return "EnvironmentValue"
}

func (v EnvironmentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var features basetypes.ObjectValue

	if v.Features.IsNull() {
		features = types.ObjectNull(
			FeaturesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Features.IsUnknown() {
		features = types.ObjectUnknown(
			FeaturesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Features.IsNull() && !v.Features.IsUnknown() {
		features = types.ObjectValueMust(
			FeaturesValue{}.AttributeTypes(ctx),
			v.Features.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"features": basetypes.ObjectType{
			AttrTypes: FeaturesValue{}.AttributeTypes(ctx),
		},
		"id":     basetypes.Int64Type{},
		"name":   basetypes.StringType{},
		"org_id": basetypes.Int64Type{},
		"region": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"features": features,
			"id":       v.Id,
			"name":     v.Name,
			"org_id":   v.OrgId,
			"region":   v.Region,
		})

	return objVal, diags
}

func (v EnvironmentValue) Equal(o attr.Value) bool {
	other, ok := o.(EnvironmentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Features.Equal(other.Features) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	return true
}

func (v EnvironmentValue) Type(ctx context.Context) attr.Type {
	return EnvironmentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EnvironmentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"features": basetypes.ObjectType{
			AttrTypes: FeaturesValue{}.AttributeTypes(ctx),
		},
		"id":     basetypes.Int64Type{},
		"name":   basetypes.StringType{},
		"org_id": basetypes.Int64Type{},
		"region": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FeaturesType{}

type FeaturesType struct {
	basetypes.ObjectType
}

func (t FeaturesType) Equal(o attr.Type) bool {
	other, ok := o.(FeaturesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FeaturesType) String() string {
	return "FeaturesType"
}

func (t FeaturesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networkOptimisedAttribute, ok := attributes["network_optimised"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_optimised is missing from object`)

		return nil, diags
	}

	networkOptimisedVal, ok := networkOptimisedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_optimised expected to be basetypes.BoolValue, was: %T`, networkOptimisedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FeaturesValue{
		NetworkOptimised: networkOptimisedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFeaturesValueNull() FeaturesValue {
	return FeaturesValue{
		state: attr.ValueStateNull,
	}
}

func NewFeaturesValueUnknown() FeaturesValue {
	return FeaturesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFeaturesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FeaturesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FeaturesValue Attribute Value",
				"While creating a FeaturesValue value, a missing attribute value was detected. "+
					"A FeaturesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FeaturesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FeaturesValue Attribute Type",
				"While creating a FeaturesValue value, an invalid attribute value was detected. "+
					"A FeaturesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FeaturesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FeaturesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FeaturesValue Attribute Value",
				"While creating a FeaturesValue value, an extra attribute value was detected. "+
					"A FeaturesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FeaturesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFeaturesValueUnknown(), diags
	}

	networkOptimisedAttribute, ok := attributes["network_optimised"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_optimised is missing from object`)

		return NewFeaturesValueUnknown(), diags
	}

	networkOptimisedVal, ok := networkOptimisedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_optimised expected to be basetypes.BoolValue, was: %T`, networkOptimisedAttribute))
	}

	if diags.HasError() {
		return NewFeaturesValueUnknown(), diags
	}

	return FeaturesValue{
		NetworkOptimised: networkOptimisedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFeaturesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FeaturesValue {
	object, diags := NewFeaturesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFeaturesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FeaturesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFeaturesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFeaturesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFeaturesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFeaturesValueMust(FeaturesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FeaturesType) ValueType(ctx context.Context) attr.Value {
	return FeaturesValue{}
}

var _ basetypes.ObjectValuable = FeaturesValue{}

type FeaturesValue struct {
	NetworkOptimised basetypes.BoolValue `tfsdk:"network_optimised"`
	state            attr.ValueState
}

func (v FeaturesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["network_optimised"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.NetworkOptimised.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_optimised"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FeaturesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FeaturesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FeaturesValue) String() string {
	return "FeaturesValue"
}

func (v FeaturesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"network_optimised": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"network_optimised": v.NetworkOptimised,
		})

	return objVal, diags
}

func (v FeaturesValue) Equal(o attr.Value) bool {
	other, ok := o.(FeaturesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NetworkOptimised.Equal(other.NetworkOptimised) {
		return false
	}

	return true
}

func (v FeaturesValue) Type(ctx context.Context) attr.Type {
	return FeaturesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FeaturesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"network_optimised": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = FlavorType{}

type FlavorType struct {
	basetypes.ObjectType
}

func (t FlavorType) Equal(o attr.Type) bool {
	other, ok := o.(FlavorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FlavorType) String() string {
	return "FlavorType"
}

func (t FlavorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return nil, diags
	}

	cpuVal, ok := cpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be basetypes.Int64Value, was: %T`, cpuAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return nil, diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	ephemeralAttribute, ok := attributes["ephemeral"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ephemeral is missing from object`)

		return nil, diags
	}

	ephemeralVal, ok := ephemeralAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ephemeral expected to be basetypes.Int64Value, was: %T`, ephemeralAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return nil, diags
	}

	gpuVal, ok := gpuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be basetypes.StringValue, was: %T`, gpuAttribute))
	}

	gpuCountAttribute, ok := attributes["gpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_count is missing from object`)

		return nil, diags
	}

	gpuCountVal, ok := gpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_count expected to be basetypes.Int64Value, was: %T`, gpuCountAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ramAttribute, ok := attributes["ram"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram is missing from object`)

		return nil, diags
	}

	ramVal, ok := ramAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram expected to be basetypes.NumberValue, was: %T`, ramAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FlavorValue{
		Cpu:       cpuVal,
		Disk:      diskVal,
		Ephemeral: ephemeralVal,
		Gpu:       gpuVal,
		GpuCount:  gpuCountVal,
		Id:        idVal,
		Name:      nameVal,
		Ram:       ramVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFlavorValueNull() FlavorValue {
	return FlavorValue{
		state: attr.ValueStateNull,
	}
}

func NewFlavorValueUnknown() FlavorValue {
	return FlavorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFlavorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FlavorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FlavorValue Attribute Value",
				"While creating a FlavorValue value, a missing attribute value was detected. "+
					"A FlavorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FlavorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FlavorValue Attribute Type",
				"While creating a FlavorValue value, an invalid attribute value was detected. "+
					"A FlavorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FlavorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FlavorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FlavorValue Attribute Value",
				"While creating a FlavorValue value, an extra attribute value was detected. "+
					"A FlavorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FlavorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFlavorValueUnknown(), diags
	}

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	cpuVal, ok := cpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be basetypes.Int64Value, was: %T`, cpuAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	ephemeralAttribute, ok := attributes["ephemeral"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ephemeral is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	ephemeralVal, ok := ephemeralAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ephemeral expected to be basetypes.Int64Value, was: %T`, ephemeralAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	gpuVal, ok := gpuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be basetypes.StringValue, was: %T`, gpuAttribute))
	}

	gpuCountAttribute, ok := attributes["gpu_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_count is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	gpuCountVal, ok := gpuCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_count expected to be basetypes.Int64Value, was: %T`, gpuCountAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ramAttribute, ok := attributes["ram"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram is missing from object`)

		return NewFlavorValueUnknown(), diags
	}

	ramVal, ok := ramAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram expected to be basetypes.NumberValue, was: %T`, ramAttribute))
	}

	if diags.HasError() {
		return NewFlavorValueUnknown(), diags
	}

	return FlavorValue{
		Cpu:       cpuVal,
		Disk:      diskVal,
		Ephemeral: ephemeralVal,
		Gpu:       gpuVal,
		GpuCount:  gpuCountVal,
		Id:        idVal,
		Name:      nameVal,
		Ram:       ramVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFlavorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FlavorValue {
	object, diags := NewFlavorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFlavorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FlavorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFlavorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFlavorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFlavorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFlavorValueMust(FlavorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FlavorType) ValueType(ctx context.Context) attr.Value {
	return FlavorValue{}
}

var _ basetypes.ObjectValuable = FlavorValue{}

type FlavorValue struct {
	Cpu       basetypes.Int64Value  `tfsdk:"cpu"`
	Disk      basetypes.Int64Value  `tfsdk:"disk"`
	Ephemeral basetypes.Int64Value  `tfsdk:"ephemeral"`
	Gpu       basetypes.StringValue `tfsdk:"gpu"`
	GpuCount  basetypes.Int64Value  `tfsdk:"gpu_count"`
	Id        basetypes.Int64Value  `tfsdk:"id"`
	Name      basetypes.StringValue `tfsdk:"name"`
	Ram       basetypes.NumberValue `tfsdk:"ram"`
	state     attr.ValueState
}

func (v FlavorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disk"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ephemeral"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ram"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Cpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu"] = val

		val, err = v.Disk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk"] = val

		val, err = v.Ephemeral.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ephemeral"] = val

		val, err = v.Gpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu"] = val

		val, err = v.GpuCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_count"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Ram.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FlavorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FlavorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FlavorValue) String() string {
	return "FlavorValue"
}

func (v FlavorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu":       basetypes.Int64Type{},
		"disk":      basetypes.Int64Type{},
		"ephemeral": basetypes.Int64Type{},
		"gpu":       basetypes.StringType{},
		"gpu_count": basetypes.Int64Type{},
		"id":        basetypes.Int64Type{},
		"name":      basetypes.StringType{},
		"ram":       basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu":       v.Cpu,
			"disk":      v.Disk,
			"ephemeral": v.Ephemeral,
			"gpu":       v.Gpu,
			"gpu_count": v.GpuCount,
			"id":        v.Id,
			"name":      v.Name,
			"ram":       v.Ram,
		})

	return objVal, diags
}

func (v FlavorValue) Equal(o attr.Value) bool {
	other, ok := o.(FlavorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cpu.Equal(other.Cpu) {
		return false
	}

	if !v.Disk.Equal(other.Disk) {
		return false
	}

	if !v.Ephemeral.Equal(other.Ephemeral) {
		return false
	}

	if !v.Gpu.Equal(other.Gpu) {
		return false
	}

	if !v.GpuCount.Equal(other.GpuCount) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Ram.Equal(other.Ram) {
		return false
	}

	return true
}

func (v FlavorValue) Type(ctx context.Context) attr.Type {
	return FlavorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FlavorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu":       basetypes.Int64Type{},
		"disk":      basetypes.Int64Type{},
		"ephemeral": basetypes.Int64Type{},
		"gpu":       basetypes.StringType{},
		"gpu_count": basetypes.Int64Type{},
		"id":        basetypes.Int64Type{},
		"name":      basetypes.StringType{},
		"ram":       basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = ImageType{}

type ImageType struct {
	basetypes.ObjectType
}

func (t ImageType) Equal(o attr.Type) bool {
	other, ok := o.(ImageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ImageType) String() string {
	return "ImageType"
}

func (t ImageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ImageValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewImageValueNull() ImageValue {
	return ImageValue{
		state: attr.ValueStateNull,
	}
}

func NewImageValueUnknown() ImageValue {
	return ImageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewImageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ImageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ImageValue Attribute Value",
				"While creating a ImageValue value, a missing attribute value was detected. "+
					"A ImageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ImageValue Attribute Type",
				"While creating a ImageValue value, an invalid attribute value was detected. "+
					"A ImageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ImageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ImageValue Attribute Value",
				"While creating a ImageValue value, an extra attribute value was detected. "+
					"A ImageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ImageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewImageValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewImageValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewImageValueUnknown(), diags
	}

	return ImageValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewImageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ImageValue {
	object, diags := NewImageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewImageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ImageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewImageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewImageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewImageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewImageValueMust(ImageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ImageType) ValueType(ctx context.Context) attr.Value {
	return ImageValue{}
}

var _ basetypes.ObjectValuable = ImageValue{}

type ImageValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v ImageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ImageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ImageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ImageValue) String() string {
	return "ImageValue"
}

func (v ImageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v ImageValue) Equal(o attr.Value) bool {
	other, ok := o.(ImageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ImageValue) Type(ctx context.Context) attr.Type {
	return ImageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ImageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = KeypairType{}

type KeypairType struct {
	basetypes.ObjectType
}

func (t KeypairType) Equal(o attr.Type) bool {
	other, ok := o.(KeypairType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KeypairType) String() string {
	return "KeypairType"
}

func (t KeypairType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KeypairValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewKeypairValueNull() KeypairValue {
	return KeypairValue{
		state: attr.ValueStateNull,
	}
}

func NewKeypairValueUnknown() KeypairValue {
	return KeypairValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKeypairValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KeypairValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KeypairValue Attribute Value",
				"While creating a KeypairValue value, a missing attribute value was detected. "+
					"A KeypairValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KeypairValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KeypairValue Attribute Type",
				"While creating a KeypairValue value, an invalid attribute value was detected. "+
					"A KeypairValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KeypairValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KeypairValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KeypairValue Attribute Value",
				"While creating a KeypairValue value, an extra attribute value was detected. "+
					"A KeypairValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KeypairValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKeypairValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewKeypairValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewKeypairValueUnknown(), diags
	}

	return KeypairValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewKeypairValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KeypairValue {
	object, diags := NewKeypairValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKeypairValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KeypairType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKeypairValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKeypairValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKeypairValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKeypairValueMust(KeypairValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KeypairType) ValueType(ctx context.Context) attr.Value {
	return KeypairValue{}
}

var _ basetypes.ObjectValuable = KeypairValue{}

type KeypairValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v KeypairValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KeypairValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KeypairValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KeypairValue) String() string {
	return "KeypairValue"
}

func (v KeypairValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v KeypairValue) Equal(o attr.Value) bool {
	other, ok := o.(KeypairValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v KeypairValue) Type(ctx context.Context) attr.Type {
	return KeypairType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KeypairValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityRulesType{}

type SecurityRulesType struct {
	basetypes.ObjectType
}

func (t SecurityRulesType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityRulesType) String() string {
	return "SecurityRulesType"
}

func (t SecurityRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return nil, diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return nil, diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	portRangeMaxAttribute, ok := attributes["port_range_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range_max is missing from object`)

		return nil, diags
	}

	portRangeMaxVal, ok := portRangeMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range_max expected to be basetypes.Int64Value, was: %T`, portRangeMaxAttribute))
	}

	portRangeMinAttribute, ok := attributes["port_range_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range_min is missing from object`)

		return nil, diags
	}

	portRangeMinVal, ok := portRangeMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range_min expected to be basetypes.Int64Value, was: %T`, portRangeMinAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	remoteIpPrefixAttribute, ok := attributes["remote_ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ip_prefix is missing from object`)

		return nil, diags
	}

	remoteIpPrefixVal, ok := remoteIpPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ip_prefix expected to be basetypes.StringValue, was: %T`, remoteIpPrefixAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityRulesValue{
		CreatedAt:      createdAtVal,
		Direction:      directionVal,
		Ethertype:      ethertypeVal,
		Id:             idVal,
		PortRangeMax:   portRangeMaxVal,
		PortRangeMin:   portRangeMinVal,
		Protocol:       protocolVal,
		RemoteIpPrefix: remoteIpPrefixVal,
		Status:         statusVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSecurityRulesValueNull() SecurityRulesValue {
	return SecurityRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityRulesValueUnknown() SecurityRulesValue {
	return SecurityRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityRulesValue Attribute Value",
				"While creating a SecurityRulesValue value, a missing attribute value was detected. "+
					"A SecurityRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityRulesValue Attribute Type",
				"While creating a SecurityRulesValue value, an invalid attribute value was detected. "+
					"A SecurityRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityRulesValue Attribute Value",
				"While creating a SecurityRulesValue value, an extra attribute value was detected. "+
					"A SecurityRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityRulesValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	portRangeMaxAttribute, ok := attributes["port_range_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range_max is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	portRangeMaxVal, ok := portRangeMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range_max expected to be basetypes.Int64Value, was: %T`, portRangeMaxAttribute))
	}

	portRangeMinAttribute, ok := attributes["port_range_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range_min is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	portRangeMinVal, ok := portRangeMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range_min expected to be basetypes.Int64Value, was: %T`, portRangeMinAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	remoteIpPrefixAttribute, ok := attributes["remote_ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ip_prefix is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	remoteIpPrefixVal, ok := remoteIpPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ip_prefix expected to be basetypes.StringValue, was: %T`, remoteIpPrefixAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewSecurityRulesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewSecurityRulesValueUnknown(), diags
	}

	return SecurityRulesValue{
		CreatedAt:      createdAtVal,
		Direction:      directionVal,
		Ethertype:      ethertypeVal,
		Id:             idVal,
		PortRangeMax:   portRangeMaxVal,
		PortRangeMin:   portRangeMinVal,
		Protocol:       protocolVal,
		RemoteIpPrefix: remoteIpPrefixVal,
		Status:         statusVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSecurityRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityRulesValue {
	object, diags := NewSecurityRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityRulesValueMust(SecurityRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityRulesType) ValueType(ctx context.Context) attr.Value {
	return SecurityRulesValue{}
}

var _ basetypes.ObjectValuable = SecurityRulesValue{}

type SecurityRulesValue struct {
	CreatedAt      basetypes.StringValue `tfsdk:"created_at"`
	Direction      basetypes.StringValue `tfsdk:"direction"`
	Ethertype      basetypes.StringValue `tfsdk:"ethertype"`
	Id             basetypes.Int64Value  `tfsdk:"id"`
	PortRangeMax   basetypes.Int64Value  `tfsdk:"port_range_max"`
	PortRangeMin   basetypes.Int64Value  `tfsdk:"port_range_min"`
	Protocol       basetypes.StringValue `tfsdk:"protocol"`
	RemoteIpPrefix basetypes.StringValue `tfsdk:"remote_ip_prefix"`
	Status         basetypes.StringValue `tfsdk:"status"`
	state          attr.ValueState
}

func (v SecurityRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["direction"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ethertype"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["port_range_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["port_range_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Direction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direction"] = val

		val, err = v.Ethertype.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethertype"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.PortRangeMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range_max"] = val

		val, err = v.PortRangeMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range_min"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.RemoteIpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ip_prefix"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityRulesValue) String() string {
	return "SecurityRulesValue"
}

func (v SecurityRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created_at":       basetypes.StringType{},
		"direction":        basetypes.StringType{},
		"ethertype":        basetypes.StringType{},
		"id":               basetypes.Int64Type{},
		"port_range_max":   basetypes.Int64Type{},
		"port_range_min":   basetypes.Int64Type{},
		"protocol":         basetypes.StringType{},
		"remote_ip_prefix": basetypes.StringType{},
		"status":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at":       v.CreatedAt,
			"direction":        v.Direction,
			"ethertype":        v.Ethertype,
			"id":               v.Id,
			"port_range_max":   v.PortRangeMax,
			"port_range_min":   v.PortRangeMin,
			"protocol":         v.Protocol,
			"remote_ip_prefix": v.RemoteIpPrefix,
			"status":           v.Status,
		})

	return objVal, diags
}

func (v SecurityRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Direction.Equal(other.Direction) {
		return false
	}

	if !v.Ethertype.Equal(other.Ethertype) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.PortRangeMax.Equal(other.PortRangeMax) {
		return false
	}

	if !v.PortRangeMin.Equal(other.PortRangeMin) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.RemoteIpPrefix.Equal(other.RemoteIpPrefix) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v SecurityRulesValue) Type(ctx context.Context) attr.Type {
	return SecurityRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at":       basetypes.StringType{},
		"direction":        basetypes.StringType{},
		"ethertype":        basetypes.StringType{},
		"id":               basetypes.Int64Type{},
		"port_range_max":   basetypes.Int64Type{},
		"port_range_min":   basetypes.Int64Type{},
		"protocol":         basetypes.StringType{},
		"remote_ip_prefix": basetypes.StringType{},
		"status":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VolumeAttachmentsType{}

type VolumeAttachmentsType struct {
	basetypes.ObjectType
}

func (t VolumeAttachmentsType) Equal(o attr.Type) bool {
	other, ok := o.(VolumeAttachmentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumeAttachmentsType) String() string {
	return "VolumeAttachmentsType"
}

func (t VolumeAttachmentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	deviceAttribute, ok := attributes["device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device is missing from object`)

		return nil, diags
	}

	deviceVal, ok := deviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device expected to be basetypes.StringValue, was: %T`, deviceAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return nil, diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.ObjectValue, was: %T`, volumeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumeAttachmentsValue{
		CreatedAt: createdAtVal,
		Device:    deviceVal,
		Status:    statusVal,
		Volume:    volumeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumeAttachmentsValueNull() VolumeAttachmentsValue {
	return VolumeAttachmentsValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumeAttachmentsValueUnknown() VolumeAttachmentsValue {
	return VolumeAttachmentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumeAttachmentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumeAttachmentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumeAttachmentsValue Attribute Value",
				"While creating a VolumeAttachmentsValue value, a missing attribute value was detected. "+
					"A VolumeAttachmentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeAttachmentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumeAttachmentsValue Attribute Type",
				"While creating a VolumeAttachmentsValue value, an invalid attribute value was detected. "+
					"A VolumeAttachmentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeAttachmentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumeAttachmentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumeAttachmentsValue Attribute Value",
				"While creating a VolumeAttachmentsValue value, an extra attribute value was detected. "+
					"A VolumeAttachmentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumeAttachmentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumeAttachmentsValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewVolumeAttachmentsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	deviceAttribute, ok := attributes["device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device is missing from object`)

		return NewVolumeAttachmentsValueUnknown(), diags
	}

	deviceVal, ok := deviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device expected to be basetypes.StringValue, was: %T`, deviceAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewVolumeAttachmentsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return NewVolumeAttachmentsValueUnknown(), diags
	}

	volumeVal, ok := volumeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be basetypes.ObjectValue, was: %T`, volumeAttribute))
	}

	if diags.HasError() {
		return NewVolumeAttachmentsValueUnknown(), diags
	}

	return VolumeAttachmentsValue{
		CreatedAt: createdAtVal,
		Device:    deviceVal,
		Status:    statusVal,
		Volume:    volumeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumeAttachmentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumeAttachmentsValue {
	object, diags := NewVolumeAttachmentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumeAttachmentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumeAttachmentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumeAttachmentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumeAttachmentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumeAttachmentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumeAttachmentsValueMust(VolumeAttachmentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumeAttachmentsType) ValueType(ctx context.Context) attr.Value {
	return VolumeAttachmentsValue{}
}

var _ basetypes.ObjectValuable = VolumeAttachmentsValue{}

type VolumeAttachmentsValue struct {
	CreatedAt basetypes.StringValue `tfsdk:"created_at"`
	Device    basetypes.StringValue `tfsdk:"device"`
	Status    basetypes.StringValue `tfsdk:"status"`
	Volume    basetypes.ObjectValue `tfsdk:"volume"`
	state     attr.ValueState
}

func (v VolumeAttachmentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["device"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume"] = basetypes.ObjectType{
		AttrTypes: VolumeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Device.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Volume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumeAttachmentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumeAttachmentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumeAttachmentsValue) String() string {
	return "VolumeAttachmentsValue"
}

func (v VolumeAttachmentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var volume basetypes.ObjectValue

	if v.Volume.IsNull() {
		volume = types.ObjectNull(
			VolumeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Volume.IsUnknown() {
		volume = types.ObjectUnknown(
			VolumeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Volume.IsNull() && !v.Volume.IsUnknown() {
		volume = types.ObjectValueMust(
			VolumeValue{}.AttributeTypes(ctx),
			v.Volume.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"device":     basetypes.StringType{},
		"status":     basetypes.StringType{},
		"volume": basetypes.ObjectType{
			AttrTypes: VolumeValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at": v.CreatedAt,
			"device":     v.Device,
			"status":     v.Status,
			"volume":     volume,
		})

	return objVal, diags
}

func (v VolumeAttachmentsValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumeAttachmentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Device.Equal(other.Device) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Volume.Equal(other.Volume) {
		return false
	}

	return true
}

func (v VolumeAttachmentsValue) Type(ctx context.Context) attr.Type {
	return VolumeAttachmentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumeAttachmentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"device":     basetypes.StringType{},
		"status":     basetypes.StringType{},
		"volume": basetypes.ObjectType{
			AttrTypes: VolumeValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = VolumeType{}

type VolumeType struct {
	basetypes.ObjectType
}

func (t VolumeType) Equal(o attr.Type) bool {
	other, ok := o.(VolumeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumeType) String() string {
	return "VolumeType"
}

func (t VolumeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bootableAttribute, ok := attributes["bootable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootable is missing from object`)

		return nil, diags
	}

	bootableVal, ok := bootableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootable expected to be basetypes.BoolValue, was: %T`, bootableAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return nil, diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumeValue{
		Bootable:    bootableVal,
		Description: descriptionVal,
		Id:          idVal,
		Name:        nameVal,
		Size:        sizeVal,
		VolumeType:  volumeTypeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVolumeValueNull() VolumeValue {
	return VolumeValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumeValueUnknown() VolumeValue {
	return VolumeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumeValue Attribute Value",
				"While creating a VolumeValue value, a missing attribute value was detected. "+
					"A VolumeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumeValue Attribute Type",
				"While creating a VolumeValue value, an invalid attribute value was detected. "+
					"A VolumeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumeValue Attribute Value",
				"While creating a VolumeValue value, an extra attribute value was detected. "+
					"A VolumeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumeValueUnknown(), diags
	}

	bootableAttribute, ok := attributes["bootable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootable is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	bootableVal, ok := bootableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootable expected to be basetypes.BoolValue, was: %T`, bootableAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	volumeTypeAttribute, ok := attributes["volume_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_type is missing from object`)

		return NewVolumeValueUnknown(), diags
	}

	volumeTypeVal, ok := volumeTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_type expected to be basetypes.StringValue, was: %T`, volumeTypeAttribute))
	}

	if diags.HasError() {
		return NewVolumeValueUnknown(), diags
	}

	return VolumeValue{
		Bootable:    bootableVal,
		Description: descriptionVal,
		Id:          idVal,
		Name:        nameVal,
		Size:        sizeVal,
		VolumeType:  volumeTypeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVolumeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumeValue {
	object, diags := NewVolumeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumeValueMust(VolumeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumeType) ValueType(ctx context.Context) attr.Value {
	return VolumeValue{}
}

var _ basetypes.ObjectValuable = VolumeValue{}

type VolumeValue struct {
	Bootable    basetypes.BoolValue   `tfsdk:"bootable"`
	Description basetypes.StringValue `tfsdk:"description"`
	Id          basetypes.Int64Value  `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Size        basetypes.Int64Value  `tfsdk:"size"`
	VolumeType  basetypes.StringValue `tfsdk:"volume_type"`
	state       attr.ValueState
}

func (v VolumeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["bootable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volume_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Bootable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bootable"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		val, err = v.VolumeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumeValue) String() string {
	return "VolumeValue"
}

func (v VolumeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bootable":    basetypes.BoolType{},
		"description": basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"size":        basetypes.Int64Type{},
		"volume_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bootable":    v.Bootable,
			"description": v.Description,
			"id":          v.Id,
			"name":        v.Name,
			"size":        v.Size,
			"volume_type": v.VolumeType,
		})

	return objVal, diags
}

func (v VolumeValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bootable.Equal(other.Bootable) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	if !v.VolumeType.Equal(other.VolumeType) {
		return false
	}

	return true
}

func (v VolumeValue) Type(ctx context.Context) attr.Type {
	return VolumeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bootable":    basetypes.BoolType{},
		"description": basetypes.StringType{},
		"id":          basetypes.Int64Type{},
		"name":        basetypes.StringType{},
		"size":        basetypes.Int64Type{},
		"volume_type": basetypes.StringType{},
	}
}
