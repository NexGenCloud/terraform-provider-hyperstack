// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_core_stocks

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func CoreStocksDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"stocks": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"models": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"available": schema.StringAttribute{
										Computed: true,
									},
									"configurations": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"n10x": schema.Int64Attribute{
												Computed: true,
											},
											"n1x": schema.Int64Attribute{
												Computed: true,
											},
											"n2x": schema.Int64Attribute{
												Computed: true,
											},
											"n4x": schema.Int64Attribute{
												Computed: true,
											},
											"n8x": schema.Int64Attribute{
												Computed: true,
											},
										},
										CustomType: ConfigurationsType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigurationsValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"model": schema.StringAttribute{
										Computed: true,
									},
									"planned_100_days": schema.StringAttribute{
										Computed: true,
									},
									"planned_30_days": schema.StringAttribute{
										Computed: true,
									},
									"planned_7_days": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ModelsType{
									ObjectType: types.ObjectType{
										AttrTypes: ModelsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"region": schema.StringAttribute{
							Computed: true,
						},
						"stocktype": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: StocksType{
						ObjectType: types.ObjectType{
							AttrTypes: StocksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
		},
	}
}

type CoreStocksModel struct {
	Stocks types.List `tfsdk:"stocks"`
}

var _ basetypes.ObjectTypable = StocksType{}

type StocksType struct {
	basetypes.ObjectType
}

func (t StocksType) Equal(o attr.Type) bool {
	other, ok := o.(StocksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StocksType) String() string {
	return "StocksType"
}

func (t StocksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	modelsAttribute, ok := attributes["models"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`models is missing from object`)

		return nil, diags
	}

	modelsVal, ok := modelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`models expected to be basetypes.ListValue, was: %T`, modelsAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	stocktypeAttribute, ok := attributes["stocktype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stocktype is missing from object`)

		return nil, diags
	}

	stocktypeVal, ok := stocktypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stocktype expected to be basetypes.StringValue, was: %T`, stocktypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StocksValue{
		Models:    modelsVal,
		Region:    regionVal,
		Stocktype: stocktypeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStocksValueNull() StocksValue {
	return StocksValue{
		state: attr.ValueStateNull,
	}
}

func NewStocksValueUnknown() StocksValue {
	return StocksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStocksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StocksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StocksValue Attribute Value",
				"While creating a StocksValue value, a missing attribute value was detected. "+
					"A StocksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StocksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StocksValue Attribute Type",
				"While creating a StocksValue value, an invalid attribute value was detected. "+
					"A StocksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StocksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StocksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StocksValue Attribute Value",
				"While creating a StocksValue value, an extra attribute value was detected. "+
					"A StocksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StocksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStocksValueUnknown(), diags
	}

	modelsAttribute, ok := attributes["models"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`models is missing from object`)

		return NewStocksValueUnknown(), diags
	}

	modelsVal, ok := modelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`models expected to be basetypes.ListValue, was: %T`, modelsAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewStocksValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	stocktypeAttribute, ok := attributes["stocktype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stocktype is missing from object`)

		return NewStocksValueUnknown(), diags
	}

	stocktypeVal, ok := stocktypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stocktype expected to be basetypes.StringValue, was: %T`, stocktypeAttribute))
	}

	if diags.HasError() {
		return NewStocksValueUnknown(), diags
	}

	return StocksValue{
		Models:    modelsVal,
		Region:    regionVal,
		Stocktype: stocktypeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStocksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StocksValue {
	object, diags := NewStocksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStocksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StocksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStocksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStocksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStocksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStocksValueMust(StocksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StocksType) ValueType(ctx context.Context) attr.Value {
	return StocksValue{}
}

var _ basetypes.ObjectValuable = StocksValue{}

type StocksValue struct {
	Models    basetypes.ListValue   `tfsdk:"models"`
	Region    basetypes.StringValue `tfsdk:"region"`
	Stocktype basetypes.StringValue `tfsdk:"stocktype"`
	state     attr.ValueState
}

func (v StocksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["models"] = basetypes.ListType{
		ElemType: ModelsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stocktype"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Models.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["models"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Stocktype.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stocktype"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StocksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StocksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StocksValue) String() string {
	return "StocksValue"
}

func (v StocksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	models := types.ListValueMust(
		ModelsType{
			basetypes.ObjectType{
				AttrTypes: ModelsValue{}.AttributeTypes(ctx),
			},
		},
		v.Models.Elements(),
	)

	if v.Models.IsNull() {
		models = types.ListNull(
			ModelsType{
				basetypes.ObjectType{
					AttrTypes: ModelsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Models.IsUnknown() {
		models = types.ListUnknown(
			ModelsType{
				basetypes.ObjectType{
					AttrTypes: ModelsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"models": basetypes.ListType{
			ElemType: ModelsValue{}.Type(ctx),
		},
		"region":    basetypes.StringType{},
		"stocktype": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"models":    models,
			"region":    v.Region,
			"stocktype": v.Stocktype,
		})

	return objVal, diags
}

func (v StocksValue) Equal(o attr.Value) bool {
	other, ok := o.(StocksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Models.Equal(other.Models) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Stocktype.Equal(other.Stocktype) {
		return false
	}

	return true
}

func (v StocksValue) Type(ctx context.Context) attr.Type {
	return StocksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StocksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"models": basetypes.ListType{
			ElemType: ModelsValue{}.Type(ctx),
		},
		"region":    basetypes.StringType{},
		"stocktype": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ModelsType{}

type ModelsType struct {
	basetypes.ObjectType
}

func (t ModelsType) Equal(o attr.Type) bool {
	other, ok := o.(ModelsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ModelsType) String() string {
	return "ModelsType"
}

func (t ModelsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return nil, diags
	}

	availableVal, ok := availableAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.StringValue, was: %T`, availableAttribute))
	}

	configurationsAttribute, ok := attributes["configurations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configurations is missing from object`)

		return nil, diags
	}

	configurationsVal, ok := configurationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configurations expected to be basetypes.ObjectValue, was: %T`, configurationsAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	planned100DaysAttribute, ok := attributes["planned_100_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`planned_100_days is missing from object`)

		return nil, diags
	}

	planned100DaysVal, ok := planned100DaysAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`planned_100_days expected to be basetypes.StringValue, was: %T`, planned100DaysAttribute))
	}

	planned30DaysAttribute, ok := attributes["planned_30_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`planned_30_days is missing from object`)

		return nil, diags
	}

	planned30DaysVal, ok := planned30DaysAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`planned_30_days expected to be basetypes.StringValue, was: %T`, planned30DaysAttribute))
	}

	planned7DaysAttribute, ok := attributes["planned_7_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`planned_7_days is missing from object`)

		return nil, diags
	}

	planned7DaysVal, ok := planned7DaysAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`planned_7_days expected to be basetypes.StringValue, was: %T`, planned7DaysAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ModelsValue{
		Available:      availableVal,
		Configurations: configurationsVal,
		Model:          modelVal,
		Planned100Days: planned100DaysVal,
		Planned30Days:  planned30DaysVal,
		Planned7Days:   planned7DaysVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewModelsValueNull() ModelsValue {
	return ModelsValue{
		state: attr.ValueStateNull,
	}
}

func NewModelsValueUnknown() ModelsValue {
	return ModelsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewModelsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ModelsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ModelsValue Attribute Value",
				"While creating a ModelsValue value, a missing attribute value was detected. "+
					"A ModelsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModelsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ModelsValue Attribute Type",
				"While creating a ModelsValue value, an invalid attribute value was detected. "+
					"A ModelsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModelsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ModelsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ModelsValue Attribute Value",
				"While creating a ModelsValue value, an extra attribute value was detected. "+
					"A ModelsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ModelsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewModelsValueUnknown(), diags
	}

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return NewModelsValueUnknown(), diags
	}

	availableVal, ok := availableAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.StringValue, was: %T`, availableAttribute))
	}

	configurationsAttribute, ok := attributes["configurations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configurations is missing from object`)

		return NewModelsValueUnknown(), diags
	}

	configurationsVal, ok := configurationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configurations expected to be basetypes.ObjectValue, was: %T`, configurationsAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewModelsValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	planned100DaysAttribute, ok := attributes["planned_100_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`planned_100_days is missing from object`)

		return NewModelsValueUnknown(), diags
	}

	planned100DaysVal, ok := planned100DaysAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`planned_100_days expected to be basetypes.StringValue, was: %T`, planned100DaysAttribute))
	}

	planned30DaysAttribute, ok := attributes["planned_30_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`planned_30_days is missing from object`)

		return NewModelsValueUnknown(), diags
	}

	planned30DaysVal, ok := planned30DaysAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`planned_30_days expected to be basetypes.StringValue, was: %T`, planned30DaysAttribute))
	}

	planned7DaysAttribute, ok := attributes["planned_7_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`planned_7_days is missing from object`)

		return NewModelsValueUnknown(), diags
	}

	planned7DaysVal, ok := planned7DaysAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`planned_7_days expected to be basetypes.StringValue, was: %T`, planned7DaysAttribute))
	}

	if diags.HasError() {
		return NewModelsValueUnknown(), diags
	}

	return ModelsValue{
		Available:      availableVal,
		Configurations: configurationsVal,
		Model:          modelVal,
		Planned100Days: planned100DaysVal,
		Planned30Days:  planned30DaysVal,
		Planned7Days:   planned7DaysVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewModelsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ModelsValue {
	object, diags := NewModelsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewModelsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ModelsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewModelsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewModelsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewModelsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewModelsValueMust(ModelsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ModelsType) ValueType(ctx context.Context) attr.Value {
	return ModelsValue{}
}

var _ basetypes.ObjectValuable = ModelsValue{}

type ModelsValue struct {
	Available      basetypes.StringValue `tfsdk:"available"`
	Configurations basetypes.ObjectValue `tfsdk:"configurations"`
	Model          basetypes.StringValue `tfsdk:"model"`
	Planned100Days basetypes.StringValue `tfsdk:"planned_100_days"`
	Planned30Days  basetypes.StringValue `tfsdk:"planned_30_days"`
	Planned7Days   basetypes.StringValue `tfsdk:"planned_7_days"`
	state          attr.ValueState
}

func (v ModelsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["available"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["configurations"] = basetypes.ObjectType{
		AttrTypes: ConfigurationsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["planned_100_days"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["planned_30_days"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["planned_7_days"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Available.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["available"] = val

		val, err = v.Configurations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configurations"] = val

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.Planned100Days.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["planned_100_days"] = val

		val, err = v.Planned30Days.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["planned_30_days"] = val

		val, err = v.Planned7Days.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["planned_7_days"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ModelsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ModelsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ModelsValue) String() string {
	return "ModelsValue"
}

func (v ModelsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var configurations basetypes.ObjectValue

	if v.Configurations.IsNull() {
		configurations = types.ObjectNull(
			ConfigurationsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Configurations.IsUnknown() {
		configurations = types.ObjectUnknown(
			ConfigurationsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Configurations.IsNull() && !v.Configurations.IsUnknown() {
		configurations = types.ObjectValueMust(
			ConfigurationsValue{}.AttributeTypes(ctx),
			v.Configurations.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"available": basetypes.StringType{},
		"configurations": basetypes.ObjectType{
			AttrTypes: ConfigurationsValue{}.AttributeTypes(ctx),
		},
		"model":            basetypes.StringType{},
		"planned_100_days": basetypes.StringType{},
		"planned_30_days":  basetypes.StringType{},
		"planned_7_days":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"available":        v.Available,
			"configurations":   configurations,
			"model":            v.Model,
			"planned_100_days": v.Planned100Days,
			"planned_30_days":  v.Planned30Days,
			"planned_7_days":   v.Planned7Days,
		})

	return objVal, diags
}

func (v ModelsValue) Equal(o attr.Value) bool {
	other, ok := o.(ModelsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Available.Equal(other.Available) {
		return false
	}

	if !v.Configurations.Equal(other.Configurations) {
		return false
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.Planned100Days.Equal(other.Planned100Days) {
		return false
	}

	if !v.Planned30Days.Equal(other.Planned30Days) {
		return false
	}

	if !v.Planned7Days.Equal(other.Planned7Days) {
		return false
	}

	return true
}

func (v ModelsValue) Type(ctx context.Context) attr.Type {
	return ModelsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ModelsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"available": basetypes.StringType{},
		"configurations": basetypes.ObjectType{
			AttrTypes: ConfigurationsValue{}.AttributeTypes(ctx),
		},
		"model":            basetypes.StringType{},
		"planned_100_days": basetypes.StringType{},
		"planned_30_days":  basetypes.StringType{},
		"planned_7_days":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigurationsType{}

type ConfigurationsType struct {
	basetypes.ObjectType
}

func (t ConfigurationsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigurationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigurationsType) String() string {
	return "ConfigurationsType"
}

func (t ConfigurationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	n10xAttribute, ok := attributes["n10x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n10x is missing from object`)

		return nil, diags
	}

	n10xVal, ok := n10xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n10x expected to be basetypes.Int64Value, was: %T`, n10xAttribute))
	}

	n1xAttribute, ok := attributes["n1x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n1x is missing from object`)

		return nil, diags
	}

	n1xVal, ok := n1xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n1x expected to be basetypes.Int64Value, was: %T`, n1xAttribute))
	}

	n2xAttribute, ok := attributes["n2x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n2x is missing from object`)

		return nil, diags
	}

	n2xVal, ok := n2xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n2x expected to be basetypes.Int64Value, was: %T`, n2xAttribute))
	}

	n4xAttribute, ok := attributes["n4x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n4x is missing from object`)

		return nil, diags
	}

	n4xVal, ok := n4xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n4x expected to be basetypes.Int64Value, was: %T`, n4xAttribute))
	}

	n8xAttribute, ok := attributes["n8x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n8x is missing from object`)

		return nil, diags
	}

	n8xVal, ok := n8xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n8x expected to be basetypes.Int64Value, was: %T`, n8xAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigurationsValue{
		N10x:  n10xVal,
		N1x:   n1xVal,
		N2x:   n2xVal,
		N4x:   n4xVal,
		N8x:   n8xVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigurationsValueNull() ConfigurationsValue {
	return ConfigurationsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigurationsValueUnknown() ConfigurationsValue {
	return ConfigurationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigurationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigurationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigurationsValue Attribute Value",
				"While creating a ConfigurationsValue value, a missing attribute value was detected. "+
					"A ConfigurationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigurationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigurationsValue Attribute Type",
				"While creating a ConfigurationsValue value, an invalid attribute value was detected. "+
					"A ConfigurationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigurationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigurationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigurationsValue Attribute Value",
				"While creating a ConfigurationsValue value, an extra attribute value was detected. "+
					"A ConfigurationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigurationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigurationsValueUnknown(), diags
	}

	n10xAttribute, ok := attributes["n10x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n10x is missing from object`)

		return NewConfigurationsValueUnknown(), diags
	}

	n10xVal, ok := n10xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n10x expected to be basetypes.Int64Value, was: %T`, n10xAttribute))
	}

	n1xAttribute, ok := attributes["n1x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n1x is missing from object`)

		return NewConfigurationsValueUnknown(), diags
	}

	n1xVal, ok := n1xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n1x expected to be basetypes.Int64Value, was: %T`, n1xAttribute))
	}

	n2xAttribute, ok := attributes["n2x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n2x is missing from object`)

		return NewConfigurationsValueUnknown(), diags
	}

	n2xVal, ok := n2xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n2x expected to be basetypes.Int64Value, was: %T`, n2xAttribute))
	}

	n4xAttribute, ok := attributes["n4x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n4x is missing from object`)

		return NewConfigurationsValueUnknown(), diags
	}

	n4xVal, ok := n4xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n4x expected to be basetypes.Int64Value, was: %T`, n4xAttribute))
	}

	n8xAttribute, ok := attributes["n8x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`n8x is missing from object`)

		return NewConfigurationsValueUnknown(), diags
	}

	n8xVal, ok := n8xAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`n8x expected to be basetypes.Int64Value, was: %T`, n8xAttribute))
	}

	if diags.HasError() {
		return NewConfigurationsValueUnknown(), diags
	}

	return ConfigurationsValue{
		N10x:  n10xVal,
		N1x:   n1xVal,
		N2x:   n2xVal,
		N4x:   n4xVal,
		N8x:   n8xVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigurationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigurationsValue {
	object, diags := NewConfigurationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigurationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigurationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigurationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigurationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigurationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigurationsValueMust(ConfigurationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigurationsType) ValueType(ctx context.Context) attr.Value {
	return ConfigurationsValue{}
}

var _ basetypes.ObjectValuable = ConfigurationsValue{}

type ConfigurationsValue struct {
	N10x  basetypes.Int64Value `tfsdk:"n10x"`
	N1x   basetypes.Int64Value `tfsdk:"n1x"`
	N2x   basetypes.Int64Value `tfsdk:"n2x"`
	N4x   basetypes.Int64Value `tfsdk:"n4x"`
	N8x   basetypes.Int64Value `tfsdk:"n8x"`
	state attr.ValueState
}

func (v ConfigurationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["n10x"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["n1x"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["n2x"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["n4x"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["n8x"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.N10x.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["n10x"] = val

		val, err = v.N1x.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["n1x"] = val

		val, err = v.N2x.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["n2x"] = val

		val, err = v.N4x.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["n4x"] = val

		val, err = v.N8x.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["n8x"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigurationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigurationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigurationsValue) String() string {
	return "ConfigurationsValue"
}

func (v ConfigurationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"n10x": basetypes.Int64Type{},
		"n1x":  basetypes.Int64Type{},
		"n2x":  basetypes.Int64Type{},
		"n4x":  basetypes.Int64Type{},
		"n8x":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"n10x": v.N10x,
			"n1x":  v.N1x,
			"n2x":  v.N2x,
			"n4x":  v.N4x,
			"n8x":  v.N8x,
		})

	return objVal, diags
}

func (v ConfigurationsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigurationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.N10x.Equal(other.N10x) {
		return false
	}

	if !v.N1x.Equal(other.N1x) {
		return false
	}

	if !v.N2x.Equal(other.N2x) {
		return false
	}

	if !v.N4x.Equal(other.N4x) {
		return false
	}

	if !v.N8x.Equal(other.N8x) {
		return false
	}

	return true
}

func (v ConfigurationsValue) Type(ctx context.Context) attr.Type {
	return ConfigurationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigurationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"n10x": basetypes.Int64Type{},
		"n1x":  basetypes.Int64Type{},
		"n2x":  basetypes.Int64Type{},
		"n4x":  basetypes.Int64Type{},
		"n8x":  basetypes.Int64Type{},
	}
}
